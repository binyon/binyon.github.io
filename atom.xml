<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WELCOME</title>
  
  <subtitle>Learn as a programmer.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://binyon.github.io/"/>
  <updated>2019-03-16T12:14:57.839Z</updated>
  <id>https://binyon.github.io/</id>
  
  <author>
    <name>BING WU</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>photoshop_study</title>
    <link href="https://binyon.github.io/2019/03/11/photoshop-study/"/>
    <id>https://binyon.github.io/2019/03/11/photoshop-study/</id>
    <published>2019-03-11T07:11:30.000Z</published>
    <updated>2019-03-16T12:14:57.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PhotoShop-学习记录"><a href="#PhotoShop-学习记录" class="headerlink" title="PhotoShop 学习记录"></a>PhotoShop 学习记录</h1><h2 id="前景色和背景色"><a href="#前景色和背景色" class="headerlink" title="前景色和背景色"></a>前景色和背景色</h2><p>切换快捷键，为x<br>恢复快捷键，为d</p><p>查看图像大小， alt+ctrl+i<br><strong>图像像素</strong>，<strong>文档大小</strong><br><strong>约束比例</strong>，限制图像长宽比例<br><strong>重定图像像素</strong>，会缩放图像长宽比例，像素会被锁定，无法输入数值</p><p><strong>新建，复位像素</strong>，按下alt键，原来的取消编程了复位，单击即可。</p><p><strong>分辨率</strong>，单位，像素每英寸，ppi一般是lpi的两倍<br><strong>点分辨率</strong>，衡量输出精度的主要参数，打印机产生的每英寸的油墨点数或显示输出设备没英寸的像素点数，dpi<br><strong>挂网</strong>，精度，衡量印刷精度的主要参数，挂网线越多画面越细腻，lpi</p><p><strong>图层</strong>，一层一层的颜料，和画图一样；每一层有不同的信息，同时可以方便修改<br><strong>打开图层</strong>，F7打开图层面板，Ctrl+shift+n打开图层<br><strong>显示和隐藏图层</strong>，图层上的小眼睛，按下alt键之后就隐藏其他所有的图层<br><strong>复制图层</strong>，ctrl + j 复制后的图层会自动显示在复制的图层上方</p><p><strong>抓手工具</strong>，移动图层位置，方便查看，快捷键为 h；或者按下空格键不松，那么就会出现抓手工具</p><p><strong>移动工具</strong>，移动图层到另外一个地方，<strong>按下shift到原来的位置</strong>，前提是两个文件的大小是一样的；如果不一样大小，会自动居中；<code>自动选择</code> 一般是不要勾选,因为图层太多容易造成误操作,如果需要的时候按下ctrl键即可实现自动选择临时使用</p><p>按下alt键复制图层,按下shift方向锁定移动;这几个键可以组合使用,实现多重复制,shift是加速的意思</p><p><strong>图层编组</strong>,将想要归并在一起的图层但是又不想合并的图层放在一起;Ctrl+g<br><code>链接图层</code> 也能实现这个效果;特别是当想要对其图层的时候有非常好的效果</p><p><strong>选区</strong>，对图像的某部分进行单独处理的时候，将某部分单独选择出来，这个部分就叫做选区;分别操作互不干扰的效果<br><code>矩形选框工具</code>，快捷键为M，</p><p>按下shift键为正方形,按下alt键选中以中心为基准的选区.<br>ctrl + d 取消选区,ctrl + shift + d 找回刚才的选区<br>ctrl+h隐藏选区,选区依然是存在的,只是没有显示</p><p>保存选区，邮件，存储选区，载入选区</p><p>按下alt键，在原来的基础上减去选区；按下shift键在原来的基础上增加选区，即变成<code>添加到选区</code></p><p>与选区交叉,同时按下shift + alt</p><p><strong>选区反向</strong>,ctrl + shift + i</p><p><strong>羽化</strong>,使选区边缘柔和过度,羽化值越大,那么越柔和,选区区域越扁平；快捷键为shift+f6</p><p><strong>套索</strong>,多边形套索,磁性套索工具.</p><p><strong>磁性套索</strong>，按下alt键和<strong>多边形套索</strong>切换</p><p>填充</p><p>填充前景色，alt+delete</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PhotoShop-学习记录&quot;&gt;&lt;a href=&quot;#PhotoShop-学习记录&quot; class=&quot;headerlink&quot; title=&quot;PhotoShop 学习记录&quot;&gt;&lt;/a&gt;PhotoShop 学习记录&lt;/h1&gt;&lt;h2 id=&quot;前景色和背景色&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>wangzherongyao</title>
    <link href="https://binyon.github.io/2019/02/28/wangzherongyao/"/>
    <id>https://binyon.github.io/2019/02/28/wangzherongyao/</id>
    <published>2019-02-28T14:28:03.000Z</published>
    <updated>2019-02-28T14:28:44.297Z</updated>
    
    <content type="html"><![CDATA[<p>一、     游戏系统架构<br>一）系统架构图</p><p>《王者荣耀》游戏分析（删减版）<br>注：红色字体为重要系统</p><p>二）系统结构说明<br>1、王者荣耀游戏类型：MOBA，即时对战类</p><p>2、游戏组成：</p><pre><code>PVP、PVE、养成及收集系统、辅助系统、任务系统、社交系统、计费系统，共7大系统组成。</code></pre><p>其中主要系统为：</p><p>1）PVP：排位模式(单人、双人、三人、五人)，匹配模式(1-5人匹配、1v1、3v3)，大乱斗(1-5人)、娱乐模式(1-5人)。</p><p>2）   养成及收集：皮肤收集、铭文养成收集、英雄收集。</p><p>其他系统：</p><p>3）PVE系统：挑战模式、六国远征、人机模式。(共3种)</p><p>4）计费系统：充值、商城、货币。(共3种)</p><p>5）社交系统：好友系统、师徒系统、聊天系统、战队系统。(共4种)</p><p>6）辅助系统：排行榜、成就、签到。(共3种)</p><p>7）任务系统：每日、节日、特殊。(共3种)</p><p>3、   该游戏中特色玩法：</p><p>PVP系统中火焰山大战：</p><p>1）   地图方面：从传统MOBA类游戏地图改进为魔兽3C类型地图。</p><p>2）   获胜条件：从MOBA类以推倒敌方基地为胜利条件改为一方队伍杀人数到30为胜利条件。</p><p>3） 玩法方面：无补刀、野怪数量减少至2个、召唤师技能数量+1、除正常移动路径外其他路径均为岩浆(玩家进入岩浆后受到伤害并减速)。</p><p>4、从系统架构图中可以看出：</p><p>1)       游戏中有丰富的PVP玩法，其中包括1V1的SOLO玩法、3人多种PVP玩法、1-5人的PVP及娱乐模式玩法，各类玩法总和可到达12次之多。提供给玩家多样化的游戏乐趣及体验。</p><p>2)      在PVP模式中，需要多人进行的游戏模式较多，强调多人游戏模式的乐趣，鼓励玩家多进行竞争、协作与交流等交互行为。</p><p>3)      游戏中具有内容含量丰富的养成及收集系统，保证玩家可以建立长期的游戏目标并且可以带给玩家成长感，延长游戏生命周期。</p><p>4)      游戏中其他系统的作用为：</p><p>(1)增加了游戏玩法的多样性</p><p>除主要系统外仍有5种系统支撑该游戏的玩法，其他每个不同系统都会给玩家带来不同的游戏乐趣及游戏体验。</p><p>(2)在玩家进行游戏体验的同时，降低玩家疲劳感和枯燥感。</p><p>除主要玩法排位及匹配赛以外，该游戏还拥有PVE、娱乐模式（火焰山大战、克隆大战等无排名无积分）的玩法。通过这些娱乐的玩法，使得玩家在排位及匹配重复玩法结束后，可以通过娱乐玩法来降低玩家的疲劳感和枯燥感。</p><p>二、游戏闭环图<br>一）闭环图<br>1、游戏整体闭环图</p><p>《王者荣耀》游戏分析（删减版）<br>2、游戏战斗核心闭环图</p><p>《王者荣耀》游戏分析（删减版）</p><p>二）闭环图说明<br>1、游戏整体闭环图说明<br>1）循环模式说明</p><p>玩家先接触游戏核心玩法，通过PVP、PVE及任务获得资源和货币，玩家通过消耗资源和货币对各种养成进行提升(铭文可提高玩家对局内基础属性，经验用来提升角色的等级)。玩家提升实力后，可以攻略更高难度的关卡，击败更厉害的玩家，以此对实力的提升进行验证。同时玩家会获得更多的资源，为进一步的成长打下基础，以此循环。</p><p>2）限制循环的方式</p><pre><code>     1、限制奖励次数：限制玩家通过PVP、PVE玩法每周可获得的经验、游戏货币的数量上限。2、限制每日任务奖励次数：玩家通过每日任务可获得经验和一定量的货币奖励，但每日限完成一次。</code></pre><p>3） 加速循环的方式</p><p> (1)充值</p><p>针对玩家群体：RMB玩家</p><p>玩家通过充值获得游戏货币可以在商城中购买玩家任何想要的核心资源等物品(例：双倍经验卡、双倍金币卡)，玩家只要花费比非拥有双倍经验卡玩家一半左右的时间就可获得同样的经验和金币。快速提升玩家成长。</p><p>(2)投入更多时间、精力</p><p>针对玩家群体：RMB玩家、时间充裕玩家</p><p>而对于充值少或不充值的玩家，可以通过花费更多的时间，参与更多的游戏内容，从而获得系统发放的免费资源，加快角色成长。</p><p>(3)提升游戏技巧，增加玩家获胜概率</p><p>针对玩家类型：全体玩家</p><p>因玩家游戏胜利获得的奖励要高于游戏失败所获得的奖励，玩家通过自身的游戏技巧锻炼，获得游戏胜利，来获得更多的资源，加快角色成长。</p><p>4） 游戏的平衡性</p><pre><code>(1)游戏自身的平衡性前期：资源获取大于资源消耗，玩家成长迅速</code></pre><p>玩家的资源获取来源于活动与丰富的任务奖励，保证了玩家的游戏体验；初始资源消耗不大，但消耗资源的玩法较多，目的是培养玩家的资源消耗习惯。</p><p>中期：资源获取小于资源消耗，玩家使用前期保存资源</p><p>到了中期，玩家资源消耗逐渐增大，而资源获取增长跟不上，开始使用前期的库存资源，玩家成长速度减慢。</p><p>后期：资源消耗远大于资源获取</p><p>到了后期资源消耗巨大，玩家通过系统赠送的免费资源及奖励远满足不了消耗，玩家需投入更多的时间精力或充值来加快玩家成长。</p><p>(2)玩家之间的平衡性</p><pre><code>付费玩家与非付费玩家之间的平衡性：</code></pre><p>付费玩家</p><p>非付费玩家</p><p>PVP</p><p>英雄数量</p><p>更多的英雄选择</p><p>更多的铭文选择（根据英雄有多套）</p><p>皮肤（数量多）</p><p>适量的英雄选择</p><p>铭文选择（根据英雄位置各1套）</p><p>皮肤（较少）</p><p>铭文</p><p>皮肤</p><p>竞技场</p><p>名次</p><p>竞技场名次(提升快)</p><p>竞技场排名(提升慢)</p><p>PVE</p><p>通关难度</p><p>通关容易，速度快</p><p>通关难度大，速度较慢</p><p>玩家游戏体验</p><p>游戏体验</p><p>体验较好</p><p>获取资源速度要高于非付费玩家</p><p>付费玩家战胜非付费玩家几率大</p><p>体验一般</p><p>通过花费更多时间来获取资源</p><p>与付费玩家有一定差距</p><p>资源获取</p><p>获胜概率</p><p>2、游戏内闭环图说明<br>         1）循环模式说明</p><p>玩家进入游戏后，消耗初始资源购买少量装备，通过游戏内的补兵，击杀敌方英雄，推塔，打野和随着游戏时间增加获取金币(装备卖出可获得该装备半价的金币)和经验。消耗金币更新装备，消耗经验帮助玩家等级成长。英雄实力提升后，可以更快的进行补兵、打野，并且可以增加击杀敌方英雄的概率，为进一步的提升实力打下基础，以此循环。</p><p>2）限制循环的方式</p><p>防御塔具有固定的数量、小兵/野怪的刷新时间固定</p><p>小兵每30秒钟刷新一次，野怪70秒/90秒刷新一次，防御塔有9个(摧毁后不刷新)，通过间隔时间来刷新小兵及野怪，使玩家获得资源进行了限制，从而限制循环。</p><p>3） 加速循环的方式</p><pre><code>玩家的游戏操作技术及游戏节奏的整体掌控、玩家间的配合</code></pre><p>因小兵的刷新和野怪的刷新是固定的，所以通过玩家的个人操作技术及队友配合掠夺敌方的野区资源，和对敌方英雄进行击杀及推塔可加快循环。</p><p>三）经济系统浅析<br>货币种类及基本说明<br>1）货币种类汇总表：</p><p>货币种类汇总表</p><p>货币转换比例：</p><p>1RMB=10点券 1点券=1钻石(只限抽奖时)</p><p>点券/钻石无法转换成金币</p><p>货币种类</p><p>获得途径</p><p>消耗途径</p><p>特点</p><p>点券</p><p>充值（唯一）</p><p>皮肤/英雄购买</p><p>提升贵族等级</p><p>点券抽奖</p><p>创建战队</p><p>喇叭购买</p><p>高级货币</p><p>可兑换全部资源</p><p>钻石</p><p>武道大会</p><p>签到</p><p>成就系统</p><p>运营活动（月卡周卡）</p><p>每日任务</p><p>部分英雄购买</p><p>扩充铭文页</p><p>中高级铭文抽奖</p><p>钻石抽奖</p><p>中级货币</p><p>可兑换部分英雄，中级铭文（约等于提升战力）</p><p>小R可通过月卡/周卡大量获得</p><p>非R靠签到/成就/资源兑换少量获得</p><p>金币</p><p>成就达成</p><p>武道大会</p><p>日常活动</p><p>PVP</p><p>英雄购买</p><p>低级铭文抽奖</p><p>普通货币</p><p>可购买除限定外所有英雄</p><p>荣耀积分</p><p>点券兑换</p><p>兑换比例1：1</p><p>积分夺宝</p><p>特殊货币</p><p>可通过抽奖来换取限定英雄/皮肤</p><p>远征币</p><p>PVE：六国远征</p><p>购买固定英雄1名</p><p>2~4级铭文</p><p>特殊货币</p><p>获取途径唯一</p><p>可购买物品少</p><p>武道币</p><p>PVE：武道大会</p><p>购买固定英雄1名</p><p>2~4级铭文</p><p>特殊货币</p><p>获取途径唯一</p><p>可购买物品少</p><p>注： 1、红色字体为主要产出/消耗途径及特点</p><pre><code>2、货币种类栏中，紫色字体货币为特殊货币</code></pre><p>2）多货币设计目的：</p><p>1、   稳定游戏经济体系</p><p>(1)只可由高级货币向低级货币兑换，对于点券作为核心货币进行了保护。</p><p>(2)三种主要货币的获取途径各不相同(获取方式参照上表)。</p><p>2、保证玩家丰富的游戏体验</p><p>根据每种货币的获取途径不同，玩家需要了解对每种货币的获取方式，并且玩家根据不同的货币获取方式不同，需要进行充值/完成任务/多进行对战的体验才可保证收益最大化。</p><p>3、适度控制玩家成长</p><p>通过多种货币的设置，玩家根据自身情况收集不同种类的货币，每种货币的获取方式及消耗时间不同，目的为分散玩家的关注点。</p><p>4、增加厂商收入</p><p>因货币只可由高级货币向低级货币兑换，高级货币可以购买任何其他货币可购买的物品，如玩家想加快自身的成长，获得更好的游戏体验，则需进行充值，从而增加厂商收入。</p><p>3）货币分析</p><p>高级货币：点券<br>货币说明：</p><p>最高等级的货币，充值可直接获得，可以购买游戏内的任何资源，无法通过玩法进行产出，无免费获得途径。</p><p>设计目的：</p><p>1、帮助玩家快速成长</p><p>通过消耗点券获取资源，从而达到玩家快速成长的目的。</p><p>2、对消费形成认知，培养玩家消费</p><p>玩家通过游戏可发现：有许多通过充值会赠送玩家更多的货币/资源的活动，当玩家与货币资源的兑换比例和充值送赠礼等运营活动进行对比，会使玩家获得一种有便宜占的心理，从而起到了培养玩家消费的作用。</p><p>3、保护付费玩家的游戏体验</p><p>因点券只可通过充值获得，保证了该货币的唯一性及稳定性。从而保护了付费玩家的游戏体验。</p><p>中级货币：钻石<br>货币说明：<br>钻石可通过点券进行1比1兑换获取，主要获得途径为月卡/周卡，次要获得途径为签到和每日任务。主要消耗在铭文抽奖，符文页购买。不具备流通性。</p><p>设计目的：</p><p>1、提高玩家活跃及在线</p><p>玩家通过每日任务、签到活动使玩家可每日稳定获得部分钻石，目的是提高玩家的上线率和活跃度。</p><p>2、培养玩家付费习惯</p><p>在游戏中后期时，铭文及铭文页购买需要大量钻石，玩家若想获得大量钻石，则需要进行月卡/周卡购买，月卡周卡需要进行点券才可进行购买，目的为培养玩家的付费习惯。</p><p>低级货币：金币<br>货币说明：</p><p>游戏的基础货币，主要可通过对战和日常活动慢慢积累。产出途径稳定，主要消耗途径是英雄购买和低级铭文抽奖。在提升付费玩家感受的同时也照顾了免费玩家的基本感受。但是玩家在每周所获得的该货币数量是有一定的上限。不具备流通性。</p><p>设计目的：</p><p>1、提高玩家的活跃度</p><p>金币因无法进行货币间的兑换，玩家只可通过对战和日常任务等进行金币获取，目的为提高玩家的在线率及活跃度。</p><p>2、保证非R玩家的游戏体验</p><p>金币是非R玩家最重要的资源，金币可以购买游戏中最重要的2个资源，英雄及铭文。</p><p>只是获取速度相比于RMB玩家较慢一些，但也保证了非R玩家的游戏体验。</p><p>3、限制玩家成长</p><p>金币每周获取数量具有上限，从而限制玩家从游戏中获取过多的货币资源。</p><p>特殊货币<br>一）荣耀积分</p><p>说明：</p><p>荣耀积分能够获取一部分的核心资源，保证玩家的高端养成。荣耀积分可适用于积分夺宝(抽奖)，玩家只能通过该抽奖方式抽取限量英雄，限量皮肤，皮肤碎片及英雄碎片。</p><p>设计目的：</p><p>1、区别玩家间的消费力水平</p><p>直接区分了大R和其他中低额度充值的玩家的消费水平：如果玩家抱着抽到限量英雄或限量皮肤的心态去抽奖，则需花费600~2100R。(运气过好的玩家除外)</p><p>2、增加玩法的多样性</p><p>鼓励玩家参与该系统，体验更丰富游戏的内容。</p><p>3、鼓励玩家消费</p><p>厂商对部分资源以“限定”的方式推出，刺激了热爱收集的玩家及RMB玩家的收集欲望，鼓励玩家进行消费。</p><p>Ø  关于通过荣耀积分抽奖可获得皮肤碎片/英雄碎片</p><p>说明：</p><p>通过荣耀积分抽奖有一定几率得到的碎片(偶尔系统会赠送少量)可以兑换部分英雄(包含一个限量英雄)及皮肤，增加了收集系统的多样性。</p><p>设计目的：</p><p>1、给与为抽中奖的玩家心理安慰</p><p>当玩家花费大量金钱使用荣耀积分抽取不到限量英雄时给予玩家一个心理缓冲带，因玩家可以通过抽奖获得的英雄碎片换取领一个限量英雄，会给玩家一定程度的心理安慰。</p><p>2、提升小R及非R玩家的付费率</p><p>小R玩家为获得另一个限量英雄，且厂商为提升大量小R玩家充值额度的一个手段。</p><p>3、下图为玩家荣耀积分抽奖简单心理流程图</p><p>《王者荣耀》游戏分析（删减版）</p><p>玩家抽奖心理变化转换到游戏行为变化：</p><p>1、   通过设定皮肤/英雄碎片，会整体提高RMB玩家的付费额度</p><p>(1)当小R玩家抽中限定后，会大幅度提高小R玩家的满足感和虚荣心，同时增加了小R玩家对该游戏的粘性。</p><p>(2)当小R玩家未抽中限定时，会刺激小R玩家的收集欲，从而继续充值。如玩家通过该次小额充值获得限定时，同样会大幅度提高玩家的满足感和虚荣心。如果玩家未抽中限定时，玩家会以得到碎片为目的，换取另一限量，增加了玩家的部分满足感。</p><p>2、游戏同时也为区分大R、中R、小R从而设定该系统。玩家可以通过是否有限定英雄/皮肤来作为不同级别的RMB玩家的一个参考。</p><p>(1)大R为满足自身收集欲望及向其他玩家的炫耀感受从而进行大量充值和抽奖。</p><p>(2)中R玩家为证明自己同样过人的经济实力，并为距离大R更近一步(抽中限定)和拉开和小R玩家的差距从而进行充值和抽奖(获取另一限量及比小R玩家更高的概率抽中限定)。</p><p>(3)小R玩家大多会抱着试试手气的心理去进行抽奖，如果抽中限定会获得极大的满足，为抽中限定的话同时也可通过获得另一限定而获得满足感，从而让小R玩家通过充值拉开与非R玩家的距离和距离中R玩家更近一步的感受。</p><p>二）远征币</p><p>说明：</p><p>通过六国远征玩法产出的货币，每天最多可获得720远征币，该货币只可在远征商店进行消费，不具备流通性。</p><p>远征商店：</p><p>在该商店中可兑换如上图所示：1名英雄及部分3、4级铭文。</p><p>远征商店物品刷新：</p><p>刷新次数</p><p>刷新1~2次</p><p>刷新3~4次</p><p>刷新5~6次</p><p>刷新7~8次</p><p>刷新9~10次</p><p>远征币消耗</p><p>10</p><p>50</p><p>100</p><p>200</p><p>400</p><p>远征币设计目的：</p><p>1、   建立游戏目标</p><p>通过每天该玩法玩家可获得一定量的货币，该货币可在远征商店进行部分资源购买，但需要玩家进行一定的时间积累，让玩家建立游戏目标。</p><p>2、   控制玩家成长节奏</p><p>因每天通过该玩法可获得的货币数量有限，从而防止控制玩家过速成长，控制玩家成长节奏。</p><p>3、   提高玩家成长速度</p><p>该玩法产出的货币对所有玩家都是相同的，有助于玩家的成长。</p><p>优点：</p><p>1、   提高玩家对于该玩法的参与度</p><p>玩家为获得更多的远征币从而参与到该玩法中，提高了玩家整体游戏体验，多参与不同类的玩法，不会让玩家觉得该游戏单调乏味。</p><p>2、   提高玩家的收集体验</p><p>玩家不在通过单一的玩法方式进行收集，而是通过各样的玩法产生不同种类的货币，从而提高玩家的收集体验。</p><p>3、   提高玩家成长速度</p><p>因每周玩家可获得的金币数量有上线，玩家若想获得更多的资源，则可参与该玩法获得货币进行资源购买，帮助玩家进行成长。</p><p>三）武道币</p><p>说明：</p><p>1、   在挑战其他玩家胜利排名上升后，系统发放的相应奖励，有钻石和武道币，排名越靠前获得奖励就越高。该货币只可在武道商店进行消费，不具备流通性。</p><p>2、   系统每天21点以后根据玩家的当前名次，次日发放相应的奖励，也是与玩家排名有关，排名越高得到的武道币也越多。200名以内，200币/天。4000名以内，60币/天。其余的都是10币/天。</p><p>武道商店：</p><p>在该商店中可兑换如上图所示：1名英雄及部分2、3级铭文。</p><p>货币设计目的：</p><p>1、   提高玩家成长速度</p><p>玩家通过该玩法获得武道币，通过该货币可以进行铭文和部分英雄购买，提高了玩家的成长速度。</p><p>2、   增加资源获取途径</p><p>玩家每周可获得货币有数量限制，玩家可以通过该玩法额外增加资源(部分2、3级铭文及1名英雄)获取途径。</p><p>3、   促进玩家游戏体验</p><p>若玩家想获得更多的资源，玩家需要进行该玩法的体验来换取货币，继而换取游戏资源。</p><p>优点：</p><p>1、提高玩家对于该玩法的参与度</p><p>玩家为获得更多的远征币从而参与到该玩法中，提高了玩家整体游戏体验，多参与不同类的玩法，不会让玩家觉得该游戏单调乏味。</p><p>2、提高玩家的收集体验</p><p>玩家不在通过单一的方式进行收集，而是通过各样的玩法产生不同种类的货币，从而提高玩家的收集体验。</p><p>3、提高玩家成长速度</p><p>因每周玩家可获得的金币数量有上线，玩家若想获得更多的资源，则可参与该玩法获得货币进行资源购买，帮助玩家进行成长。</p><p>总结<br>不同消费水平玩家的游戏体验：</p><p>1、非R玩家：可以通过长时间在线，获得一定量的资源，并在等级上超越其他玩家。也可以偶尔登陆，以休闲娱乐为主。主要群体以学生为主。</p><p>2、小R玩家：月卡/周卡可以提供大量的钻石，玩家每天至少愿意登陆一次，领取奖励，月卡提供的钻石基本可以体验比小R较多的养成项目，再加上长时间在线，可以获得一个很棒的游戏体验。主要群体以部分学生以及少量上班族为主，是游戏中最多的游戏群体。</p><p>3、中R玩家：充值可以提供大量的核心(养成和收集)资源，因该游戏为MOBA类游戏，所以与其他类型游戏相比，并不能在战力上直接体现出与非R及小R的区别。</p><p>4、大R玩家：追求排行榜的前列，希望有非常好的游戏体验，充值可以在游戏的世界中获得极大的成就感，可以满足现实中无法满足的欲望。</p><p>综上所述，付费充值实际上是玩家通过金钱成本的方式代替时间成本和精力，并且金钱成本的代价要小于时间成本和精力，可见设计者更鼓励玩家充值体验游戏。</p><p>三、       游戏核心玩法<br>一）核心玩法说明<br>5v5玩家间即时对战类以摧毁敌方水晶为目的进行战斗的游戏。</p><p>Ø   游戏玩法介绍(战斗开始前准备)</p><p>(一)  首先进入1分钟的准备界面，在一分钟内需要进行：选英雄，皮肤，铭文页，召唤师技能以及确定。</p><p>(二)  在排位等级到达钻石及以上(或者队友有钻石及以上排位等级)时，双方阵营玩家   需要分别进行禁选2名英雄。(分别由4,5楼来完成禁选时间为25秒) 。</p><p>(三)  最后调整20秒，进入游戏。</p><p>Ø   对局内游戏玩法介绍</p><p>(一)  对局开始时，每个玩家有5秒钟左右的出门准备买装备时间，5秒钟结束后，双方基地开始分别向3条路出小兵。届时玩家也应该准备往各条路走，到达战场。(时间约为游戏开始时的30秒)</p><p>(二)  当一方玩家摧毁另一方玩家水晶及对方玩家投降时，游戏胜利。</p><p>二）游戏乐趣性分析<br>策略性分析<br>战斗外策略：</p><p>1、铭文的选择</p><p>在战斗外可选择不同的铭文的种类搭配：</p><p>铭文共分为三大类，五个等级，根据不同的英雄/位置装配合适的符文组合。</p><p>在多种类的符文可以生成不同种组合，玩家的选择性也会变多，并且会直接影响玩家间的战斗。铭文系统会自带“铭文推荐”功能，为每个英雄如何选择铭文做了合适的推荐，目的是降低玩家的学习成本和降低游戏难度。</p><p>2、皮肤购买</p><p>战斗外可进行购买/选择皮肤：</p><p>皮肤可以在战斗内有少量的属性加成，少量属性加成会对玩家的对局初期有少量的影响，如果两个玩家操作水平相同，那么该少量属性可能会决定一次玩家间的击杀成功/失败。所以进行皮肤购买也是战斗外策略之一。</p><p>3、英雄熟练度</p><p>查看攻略/花费更多时间进行游戏：</p><p>玩家通过对自身所玩的英雄的熟练度，以及对队友和对手的英雄的了解程度，会直接影响游戏的胜负。所以玩家需要多参与游戏，及查看英雄攻略增加对英雄的理解程度，从而达到胜利的目的。</p><p>4、阵容搭配/组合</p><p>阵容搭配和选择会直接决定游戏是否胜利</p><p>当玩家操作水平相近时，玩家可通过在战斗前通过对队友及对手选择英雄的观察，从而选择更合适的英雄来补齐本方阵容的缺陷或对敌方英雄进行针对，来增加本方的胜利系数。</p><p>战斗内策略：</p><p>一） 单人游戏策略：</p><p>玩家在进行单人游戏时，可通过以下几点来提高自己获胜几率：</p><p>1、   1V1为主，提高自身操作操作</p><p>玩家在单人游戏时，因无队友的帮助和额外敌人的骚扰，玩家只需把注意力放在当前对线的人面前，玩家需要提高自己的操作来达到胜利的目的。</p><p>2、   1V1为主，加深自己的英雄池深度</p><p>玩家在单人游戏时，要根据敌方英雄的不同选择来进行选择英雄，从而达到克制的目的，所以玩家需要加深自身英雄池的深度。</p><p>3、   改变自己的出装策略</p><p>在对线中，根据敌方玩家的英雄和敌方英雄的出装策略来改变自己的出装。</p><p>二） 多人游戏策略：</p><p>当玩家进行多人游戏时，因无法了解其他队友的具体实力以及个人游戏风格，玩家可通过：</p><p>1、   增强自身操作水平及游戏节奏的掌控</p><p>玩家通过对自身所使用的英雄进行多次练习，加深对该英雄的理解，可以增加自己所在分路对线的优势。如使用打野英雄，可以帮助弱势队友改变弱势情形及帮助优势队友扩大优势。</p><p>2、   多与队友进行交流沟通，达到节奏一致或相近</p><p>因在单人进行游戏中，无法了解路人队友的游戏思路及操作水平。所以要多与队友进行沟通，争取达到一致节奏，从而掌控整体游戏节奏。当队友游戏节奏相同时，才会增加胜利的可能性。</p><p>3、   减少玩家间的争执、及时调整心态</p><p>玩家间偶尔会因为失误或游戏节奏不同从而产生争执。玩家如果可以平复自己的游戏心态，调节队友间的气氛，减少争执，才可让自己离胜利更进一步。</p><p>4、   选择自己合适的位置(路线)进行游戏</p><p>玩家需要通过大量游戏来发现自己所擅长的位置，多走自己的优势位置，发挥自身长处，来提高游戏胜利。</p><p>操作性分析<br>基础操作按钮及技能数量设计分析：</p><p>右侧操作按键有：回城，恢复，召唤师技能，3个英雄技能及攻击(平A)按键</p><p>如下图所示：</p><p>《王者荣耀》游戏分析（删减版）<br>站位/走位：</p><p>左摇杆控制英雄的移动及移动方向，在MOBA类游戏中对玩家的走位及站位要求较高。走位/站位的成败会直接影响到对局的胜利。</p><p>左侧摇杆设置大小及操作范围合理，既不会让玩家对屏幕的操控有影响，也不会对屏幕的观看造成影响。</p><p>技能释放：</p><pre><code>每名英雄会具有一定蓝量/能量/或无消耗(蓝量和能量可自然回复，能量无法通过补给回复)。</code></pre><p>英雄共有3个主动技能，一个被动技能。当英雄到达4级后可以学习大招。</p><p>3个主动技能的目的：</p><p>因在玩家控制手机操作时，手机既是屏幕(输出设备)，也是控制台(输入设备)。当技能过多(4个及以上)时：</p><ol><li><p>玩家出现手误的可能性提高。</p></li><li><p>玩家对屏幕的观看增加了难度。</p></li><li><p>增加了玩家的游戏学习成本。</p></li></ol><p>游戏上手难度：该游戏对新手比较友好，按键数量较少，上手简单。极大程度简化了端游的复杂按键组合。但要玩到中、高级水平需要一定的操作水平及意识和必要的团队配合。</p><p>操作模式介绍</p><p>(1)简单操作方式：</p><p>《王者荣耀》游戏分析（删减版）</p><p>说明：</p><p>如上图所示，除技能外，只有攻击按键。攻击优先级为：</p><p>距离近的英雄&gt;距离远的英雄&gt;距离近的小兵&gt;距离远的小兵&gt;防御塔</p><p>设计目的：</p><p>为了照顾刚进入游戏，对操作不熟练的新手而设置的简单版操作。</p><p>优点：</p><p>简化操作，玩家上手简单。</p><p>(2)普通操作方式：</p><p>说明：</p><p>《王者荣耀》游戏分析（删减版）</p><p>如上图所示，除了攻击键以外，额外增加了两个较小的按钮：补刀和推塔：</p><p>当按补刀按钮的时候只会进行补刀/打野/BOSS，推塔时需要按推塔按钮才会进行推塔，按攻击键只会对地方英雄造成攻击。</p><p>例外情况：</p><p>(1)当周围无小兵/防御塔/野怪，只有敌方英雄时，按补刀键和推塔键会攻击敌方最近的英雄。</p><p>(2)当周围无敌方英雄时，只有小兵/野怪/防御塔时，按攻击键也会进行攻击。(近目标优先)</p><p>设计目的：</p><p>当玩家熟练基本操作后并且对自己操作有着进一步提高要求的玩家所适合选择的方式。</p><p>让操作比简单模式更加细化。</p><p>优点：</p><pre><code>1、两个小按钮大小合适，减少玩家误操作的可能性。2、操作目的鲜明。</code></pre><p>因该操作方式比简单操作方式多了两个按钮，玩家可以根据自己的目的去选择不同 的操作按键。</p><pre><code>3、虽多了两个按钮，但并不影响游戏中玩家的视线。UI设计合理，大小适中，不会因为按钮增加而增加玩家误操作的可能性，提高玩家的游戏体验。</code></pre><p>(3)进阶操作方式：</p><p>说明：</p><p>《王者荣耀》游戏分析（删减版）</p><p>如上图所示，与上个操作按钮不同，这次改为两个靠屏幕的长按钮。</p><p>点击英雄按钮：锁定/切换锁定敌方英雄</p><p>点击小兵按钮：锁定/切换锁定敌方小兵</p><p>设计目的：</p><p>为了让玩家更精准的找到自己想攻击的目标，达到精确打击的目的。</p><p>优点：</p><p>相比普通操作方式更节约操作空间。</p><p>(4)最适宜操作方式：</p><p>《王者荣耀》游戏分析（删减版）</p><p>如上图所示：</p><p>在(2)普通操作方式基础上，增加了视野可见范围内敌方英雄头像在技能上方显示，点击敌方头像会做出普通攻击动作。</p><p>设计目的：</p><p>更适用于高操作玩家的一种操作方式。对比(3)进阶操作方式中的切换按钮，玩家更能节约时间，并且可以通过看技能上防敌方英雄头像按钮比看地图才能得知敌方英雄的出现要更为方便。</p><p>优点：</p><p>增加操作的针对性。满足高操作玩家对操作的需求。</p><p>玩家欲望性分析<br>成长欲：对应所有玩家。</p><p>游戏体验：角色成长（等级提升），收集更多的资源(英雄、皮肤、铭文)操作更熟练。</p><p>限制因素：角色成长、操作熟练度可通过长时间在线游戏练习提高，部分核心资源需要充值获取，或者长时间在线游戏以一种较慢的成长速度成长。</p><p>提供给该类玩家的福利：可通过长时间游戏时间玩家可缓慢成长。</p><p>好胜心：对应大部分玩家。</p><p>游戏体验：战胜对战方玩家，获得较高的排名，被看不起之后希望能被看的起。</p><p>限制因素：核心资源数量(影响低)，操作熟练度。</p><p>提供给该类玩家的福利： PVP的排行榜系统。</p><p>收集欲：对应收集型玩家。</p><p>游戏体验：成就收集，皮肤、英雄收集。游戏的策略性技巧探索，探索游戏的各个系统的机制。</p><p>限制因素：充值、游戏时间。</p><p>提供给该类玩家的福利：玩家通过长时间在线，可收集大多资源、成就。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、     游戏系统架构&lt;br&gt;一）系统架构图&lt;/p&gt;
&lt;p&gt;《王者荣耀》游戏分析（删减版）&lt;br&gt;注：红色字体为重要系统&lt;/p&gt;
&lt;p&gt;二）系统结构说明&lt;br&gt;1、王者荣耀游戏类型：MOBA，即时对战类&lt;/p&gt;
&lt;p&gt;2、游戏组成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PVP
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python 直接赋值、浅拷贝和深拷贝之间区别</title>
    <link href="https://binyon.github.io/2019/02/26/python-copy-deepcopy/"/>
    <id>https://binyon.github.io/2019/02/26/python-copy-deepcopy/</id>
    <published>2019-02-26T05:59:48.000Z</published>
    <updated>2019-02-26T06:19:34.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容参考"><a href="#内容参考" class="headerlink" title="内容参考"></a>内容参考</h2><pre><code>http://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html</code></pre><h2 id="解释说明"><a href="#解释说明" class="headerlink" title="解释说明"></a>解释说明</h2><ul><li>直接赋值：其实就是对象的引用（别名），改变一个另外一个也会改变</li></ul><p>对于可变或包含可变项的集合，有时需要一个副本，因此可以更改一个副本而不更改另一个副本，这就是浅拷贝和深层拷贝出现的原因</p><ul><li><p>浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的（可变）子对象，父对象是独立的，但是子对象的指向是相同的，采用对象的引用</p></li><li><p>深拷贝(deepcopy)： 需要导入copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象，两者是独立的</p></li></ul><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 赋值引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a对象是一个字典，字典的值是一个列表，是一个`可变对象`</span></span><br><span class="line">a = &#123;<span class="number">1</span>:[<span class="number">1</span>,<span class="number">234</span>,<span class="number">3</span>]&#125;</span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给b的值中增加一个元素</span></span><br><span class="line">b[<span class="number">1</span>].append(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 输出a，b的值</span></span><br><span class="line">print(a,b) <span class="comment"># &#123;1: [1, 234, 3, 2]&#125; &#123;1: [1, 234, 3, 2]&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 浅拷贝,深拷贝</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">2</span>,[<span class="string">'a'</span>,<span class="string">'b'</span>]]</span><br><span class="line"></span><br><span class="line">b = a.copy() <span class="comment">#或者导入copy模块,使用copy.copy(a)</span></span><br><span class="line">c = copy.deepcopy(a)</span><br><span class="line"></span><br><span class="line">a.append(<span class="number">5</span>)</span><br><span class="line">a[<span class="number">4</span>].append(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'a = '</span>, a) <span class="comment">#a =  [1, 12, 3, 2, ['a', 'b', 2], 5]</span></span><br><span class="line">print(<span class="string">'b = '</span>, b) <span class="comment">#b =  [1, 12, 3, 2, ['a', 'b', 2]]</span></span><br><span class="line">print(<span class="string">'c = '</span>, c) <span class="comment">#c =  [1, 12, 3, 2, ['a', 'b']]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内容参考&quot;&gt;&lt;a href=&quot;#内容参考&quot; class=&quot;headerlink&quot; title=&quot;内容参考&quot;&gt;&lt;/a&gt;内容参考&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;http://www.runoob.com/w3cnote/python-understanding-dic
      
    
    </summary>
    
      <category term="Python" scheme="https://binyon.github.io/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>搜索技巧</title>
    <link href="https://binyon.github.io/2019/02/23/web%20search%20skills/"/>
    <id>https://binyon.github.io/2019/02/23/web search skills/</id>
    <published>2019-02-23T13:42:01.000Z</published>
    <updated>2019-02-26T06:21:55.362Z</updated>
    
    <content type="html"><![CDATA[<ol><li>短语搜索</li></ol><p>搜索引擎对于用户检索的关键词并不会进行完全匹配搜索，对于多个关键词的检索一般会进行单个关键词的检索而给出结果页面，造成我们搜索到额结果不符合预期，从而费力去手动去筛选信息，这并不符合我们的工作高效率的原则。Google给我们提供了一种方法，叫做短语搜索的。通过给你的几个关键词加上引号，搜索得到的结果将会和你的关键词完全匹配，包括关键词的顺序都一致。</p><ol start="2"><li>模糊搜索，~<br>Link，查询与这个网站祥光的的网站信息<br>Site，查询该域名小的所有网站信息，site:youku.com<br>尽量少使用all开头的特殊匹配字符查询。</li></ol><ul><li><p><code>&quot;&quot;</code> 双引号<br>将要搜索的内容放入双引号中，代表完全匹配要搜索的内容，并且顺序一致。</p></li><li><p><code>-</code> 减号<br>排除减号后面的内容，减号前面有空格，后面没有空格，如“搜索 -引擎”。相应的还有加号“+”可以在但是不强制要求，可以使用空格代替，一般用于多个关键词检索，减小搜索范围，排除其他出现的干扰词</p></li><li><p><code>通配符*</code><br><em>表示任一的意思，遇到有什么东西记得不清楚了可以采用这种方法模糊搜索，如“</em>不见黄河之水”“蜀*难”</p></li><li><p><code>inurl</code><br>如“inurl:搜索引擎优化”，表示在搜索的网址中的包含后面的关键词“搜索引擎优化”，而不是网页内容中包含后面的内容，一般出现的是如百度百科，维基百科之类的网页词条介绍</p></li><li><p><code>inanchor</code><br>锚链接内容搜索，计算机专用的术语，表示一个锚中出现有后面的内容的词语，可以理解为链接的别名，但是最后的搜索结果不一定包括有后面你要求的内容。如“inanchor：登陆”</p></li><li><p><code>intitle</code><br>搜索网页html title标签包含的内容，主要用于专业人士使用。如“intitle:豆瓣”</p></li><li><p><code>allintitle</code><br>intitle的进阶版本，用于title标签中的多个关键词搜索，如“allintitle:豆瓣 知乎 区别”</p></li><li><p><code>allinurl</code><br>inurl的进阶版，“allinurl:豆瓣 知乎”就相当于“inurl:豆瓣 inurl:知乎”</p></li><li><p><code>filetype</code><br>指定特定文件搜索类型，如“filetype:pdf c语言”，“filetype:docx 食品健康”主要用于资源的搜索，像视频种子资源的搜索之类的</p></li><li><p><code>site</code><br>指定搜索的站点，在特定的网站内搜索，如“site:youku.com 一路向西”</p></li><li><p><code>related</code><br>related:youku.com 返回的是与优酷有关的网站，排除了优酷网站本身，具体相关性无法考证，只适用于Google</p></li><li><p><code>~</code><br>模糊匹配搜索，在前面或者是后面。</p></li></ul><p>以上的命令都可以互相组合后再用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;短语搜索&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;搜索引擎对于用户检索的关键词并不会进行完全匹配搜索，对于多个关键词的检索一般会进行单个关键词的检索而给出结果页面，造成我们搜索到额结果不符合预期，从而费力去手动去筛选信息，这并不符合我们的工作高效率的原则。Google给我们
      
    
    </summary>
    
      <category term="实用技巧" scheme="https://binyon.github.io/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>对按摩保健的认识</title>
    <link href="https://binyon.github.io/2019/02/21/Massage%20Care%20paper/"/>
    <id>https://binyon.github.io/2019/02/21/Massage Care paper/</id>
    <published>2019-02-21T13:27:28.000Z</published>
    <updated>2019-02-26T06:23:11.221Z</updated>
    
    <content type="html"><![CDATA[<p>经过了半个学期九周时间对按摩保健的学习，我学习到了什么是按摩，知道了什么是按摩什么是推拿，以及按摩的作用和好处，同时了解了它的常见手法。</p><p>在认识按摩的保健作用之前，我们需要知道什么是按摩，以及按摩和我们常说的推拿之间有什么区别。</p><h2 id="什么是按摩"><a href="#什么是按摩" class="headerlink" title="什么是按摩"></a>什么是按摩</h2><p>按摩是运用手、指的技巧，在人体皮肤、肌肉组织上连续动作来达到缓解身体病症和缓解疲劳的目的，具有一定的治疗作用。这种方法，叫做按摩疗法。按摩的法语为（Massage），直译过来就是我们常说的“马杀鸡”，我们日常说的“走啊，马杀鸡去”，就是说去按摩。</p><p>按摩是以中医的脏腑、经络学说为理论基础，并结合西医的解剖和病理诊断，而用手法作用于人体体表的特定部位以调节机体生理、病理状况，达到理疗目的的方法，从性质上来说，它是一种物理的治疗方法。从按摩的治疗上，可分为保健按摩、运动按摩和医疗按摩。而同一种按摩中又分为很多种，如运动按摩中，有运动前按摩和运动后按摩，训练前按摩等，通过这些方法能够促进运动员身体、心理达到一个良好的状态，增强训练效果和提高体育成绩，是按摩在运动中的一个很好的实际运用。</p><h2 id="按摩的历史"><a href="#按摩的历史" class="headerlink" title="按摩的历史"></a>按摩的历史</h2><p>从历史上来来说，按摩可以追溯到原始社会。在原始社会，原始人在生产劳动时或与野兽搏斗中，必定有一些外伤发生。出现疼痛，他们自然地用手去抚摸，按揉逐步收到效果；当人体的某一部位受到损伤出血时，人们便本能地用手按压以止血；当损伤使局部部位隆起时，人们又本能地通过抚摩、揉动使隆起变小或消失，从而缓解了肿痛。另外人们发现，用石片等刮擦某些部位能缓解一些特定的病痛，人类本能地重复应用一些能够祛病的抚摸按揉手法，经过时间的延续，这些手法得到发展和积累。在长期的认识实践过程中，按摩逐渐从无意识的偶然动作演变成为人们自由运用的系统的治疗方法。约在几千年前，我国祖先就为按摩奠定了基础，随着后来人们对于人体的认识逐步加深以及后来医学的进步，这些手法就逐步形成了我国的按摩学科。</p><h2 id="按摩的手法"><a href="#按摩的手法" class="headerlink" title="按摩的手法"></a>按摩的手法</h2><p>按摩是古称，我国在明代以前是将按摩和推拿统称为按摩，而明代之后就将其改名为推拿。这不但是简简单单的名称的变化，而是表示人们对于按摩这一手法的发展和人们对于这一手法的认识的提高。早期的按摩疗法仅用于少数疾病的治疗，手法种类也很少，常用的是按和摩两种手法，按法是单纯的向下用力，即所谓“按而留之”，摩法则是在体表作环行摩擦，属平动的范围。以后随着治疗范围的扩大，手法也相应有了发展，除了按法、摩法等常用手法外，又出现了推法。推法虽也属平动类手法，但却是一种有方向性选择的直线摩擦手法，因此对疾病的治疗更有针对性。在实践中，人们发现手法用力方向的不同对疗效有一定的影响，从而产生了各种用力方向不同的手法。除向下的压力外，还有向上的提力以及相对用力的挤压等。手法的分类也逐渐合理，适应症也逐渐扩大，按摩这一名称逐渐被推拿这个更为明确的概念所取代。可以说由按摩改称推拿，标志着推拿发展史上的一个很大的飞跃。</p><h2 id="什么是推拿"><a href="#什么是推拿" class="headerlink" title="什么是推拿"></a>什么是推拿</h2><p>按摩侧重于保健和疲劳的消除，而推拿更加侧重于疾病，现代医院中只存在推拿科，而按摩则是普遍存在于民间的社会机构中。同时相关的从业人员的叫法也不一样，从事按摩的的多以盲人按摩师为主，经过短时间的培训，通过劳动局颁发的上岗证就可以持证上岗工作了。而推拿的从业人员需要专科学历，他们当中大多数医学院出身的，其中不乏硕士、博士、博士后、他们当中还有主治医师、主任医师、教授等。同时要具备有行医资格，需要通过国家执业医师考试，相对于按摩来说，对从业人员的要求较高、较严格。</p><p>保健按摩是用按摩手法达到养身保健目，是中医保健方法之一，以健身防病为主，诊治病伤为辅。推拿（治疗按摩）包括伤科推拿，是中医外治疗法之一，是应用推拿手法达到治病目的的物理疗法，人类最古老的一种是治疗疾病的方法，以诊治疾病为主，健身防病为辅。</p><h2 id="按摩和推拿手法的区别"><a href="#按摩和推拿手法的区别" class="headerlink" title="按摩和推拿手法的区别"></a>按摩和推拿手法的区别</h2><p>按摩和推拿的手法也有很大的区别。按摩只是简单的手推或者是按捏，主要是按、摩、揉、弹、叩、敲等，家庭成员通过简单的学习就可以相互按摩。同时按摩力度基本没有什么变化，只能触及皮肤或者是肌肉组织的表层，对于更加深层的病灶没有良好的治疗效果。推拿手法的要求是柔和、均匀、有力、持久，针对穴位达到深透。针对不同的疾病，身体的不同部位有不同的推拿手法和技巧。推拿具有舒经通络、促进气血运行、调整脏腑功能、润滑关节、增强人体抗病能力等作用。对运动系统、神经系统常见疾病的治疗，效果非常明显。对一些慢性病也可以作为辅助治疗，如消化不良、便秘、胃病等。要求推拿医师都应具备完整的医学常识如解剖、生理、放射医学等和专业知识，不是人人皆可为之的。</p><h2 id="按摩的作用"><a href="#按摩的作用" class="headerlink" title="按摩的作用"></a>按摩的作用</h2><p>我们知道了按摩和推拿之间的区别以及应用范围，那么按摩保健有什么作用呢？根据名称来说，可以确定的是有保健作用的。那么具体是在那些方面呢？一些就是一些按摩的常见的保健作用。</p><p>根据现代医学的认识，按摩对肌肉、关节、韧带、肌腱、心血管，神经系统，呼吸系统，消化系统，泌尿生殖系统等有显著的作用。下面是具体的作用。</p><ul><li><p>对肌肉的作用，改善肌肉的营养代谢，增强肌肉张力和弹性，使血液，淋巴回流加快，加快血乳酸的清除，促进疲劳的恢复，促进胶乳中致痛、致炎物质的分解和稀释，使炎症消退，提高“痛阀”，释放“阿片”样物质，有明显的镇痛作用，可延长肌肉的有效作用时间，延长肌肉老化时间。<br>对关节，韧带，肌腱的作用，可消除关节内炎症及积液，可促进损伤肌肉和肌腱的恢复，恢复弹性和柔韧性，松解关节粘连，恢复关节功能，可使关节局部温度升高，治疗冷痛症。</p></li><li><p>对心血管的作用，能促进损伤组织血管网的重建，有利于损伤组织的修复，可使血液动力学得到改善，改善血粘度，减缓血管硬化程度，改善微循环和脑循环，降低血管外阻力，能改善心肌缺血状态。</p></li><li><p>对神经系统的作用，可调节大脑皮层的兴奋与一直过程，可使末梢神经的兴奋性降低，镇痛作用，可使神经性疲劳得到快速恢复。</p></li><li><p>对呼吸系统的作用，调整胸隔、肺的状态，从而产生镇咳、平喘、化痰的作用，可加深呼吸、增加氧气的吸入和二氧化碳的排除、修复肺的弹性，使呼吸肌发达，增加肺活量。</p></li><li><p>对消化系统的作用，可使消化腺分泌增加，促进消化吸收，对胃肠道消化功能调整作用，治疗腹泻和便秘，可促进胆囊的排空能力，可抑制平滑肌的痉挛。</p></li><li><p>对泌尿生殖系统的作用，可调节膀胱张力和括约肌的功能，对女性月经周期有明显的调节作用，促进乳腺发育、分泌、预防乳腺增生，有改善性功能的作用。</p></li></ul><p>知道了按摩的好处之后，我们应该怎样来进行日常的按摩保健呢？我们只需要记住下面的这些口诀就好了，发常梳，面常檫，目常运，鼻常揩，齿常叩，耳常弹，腹常摩，腰常拍，足常搓，肢常摇。</p><h2 id="按摩的注意事项"><a href="#按摩的注意事项" class="headerlink" title="按摩的注意事项"></a>按摩的注意事项</h2><p>在按摩中我们有以下需要注意的事项，注意事项：</p><ol><li>按摩前要修整指甲、热水洗手，同时，将指环等有碍操作的物品，预先摘掉。</li><li>态度要和蔼，严肃细心，要耐心地向患者解释病情，争取患者合作。</li><li>患者与医生的位置要安排合适；特别是患者坐卧等姿势，要舒适而又便于操作。</li><li>按摩手法要轻重合适，并随时观察病人表情，使患者有舒服感。</li><li>按摩时间，每次以20～30分钟为宜，按摩次数以十二次为一疗程。</li><li>患者在大怒、大喜、大恐、大悲等情绪激动的情况下，不要立即按摩。</li><li>饱食之后，不要急于按摩，一般应在饭后二小时左右为宜。</li><li>按摩时，有些患者容易入睡，应取毛巾盖好，以防着凉，注意室温。当风之处，不要按摩。可以由他人按摩，也可以自我按摩。</li></ol><p>当然按摩不是万能的，对于有些严重疾病症状，我们不要盲目相信按摩，而要及时送医院，以免耽误最佳的治疗时间，造成人生的悲剧。</p><h2 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h2><p>通过半个学期，18节课的学习，其实没有学习到很多的关于按摩手法的具体知识，学到的更多的是关于认知方面的。<br>其中有这样的一种手法，在腹泻的时候，通过按摩的摩法，逆时针在腹部按揉，可以缓解腹泻的症状，其实这样的手法和物理是相同的，腹泻不就是食物流经小肠的时候速度太快了吗，通过逆时针按摩的方法，可以在一定程度上减缓它的流动速度，从而达到缓解腹泻症状的效果。</p><p>通过这样的学习我了解到了，学科知识之间是相互连通的，以前我们学过的东西物理、化学、生物学等知识就在这上面排上了用场，有了用武之地。</p><p>在我看来按摩就是通过外力，物理的方法刺激身体的退化或者是老化的肌肉组织等重新恢复活力的一种方式。达到保证身体的正常生命活动的进行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经过了半个学期九周时间对按摩保健的学习，我学习到了什么是按摩，知道了什么是按摩什么是推拿，以及按摩的作用和好处，同时了解了它的常见手法。&lt;/p&gt;
&lt;p&gt;在认识按摩的保健作用之前，我们需要知道什么是按摩，以及按摩和我们常说的推拿之间有什么区别。&lt;/p&gt;
&lt;h2 id=&quot;什么是
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://binyon.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows 10 中Ubuntu子系统 文件互访</title>
    <link href="https://binyon.github.io/2019/02/18/window10-sublinux/"/>
    <id>https://binyon.github.io/2019/02/18/window10-sublinux/</id>
    <published>2019-02-18T15:10:13.000Z</published>
    <updated>2019-02-18T15:25:34.415Z</updated>
    
    <content type="html"><![CDATA[<p>简单的说，Windows的系统盘被挂载到了<code>/mnt</code>目录下,</p><p>我们用命令 <code>wsl</code> 系统安装的linux子系统, 使用 <code>cd /mnt</code> 切换到对应的目录, 使用<code>ls</code>命令列出当前的目录下的文件夹,可以看到就是我们的两个系统盘的盘符,我有两个盘,一个C盘和一个D盘.</p><p>//todo</p><p>我们成功切换到了系统盘之后, 可以直接在<code>bash</code>中使用各种linux下的命令,如mv, cp, 等一系列命令.</p><p>也可以切换到对应的目录编辑文档.</p><p>比如说我这个博客就是在Ubuntu下建立的,现在切换到Windows平台下, 使用wsl就可以完成以前在Ubuntu上的操作.没有任何差别.</p><p>如果有差别的话,就是<code>编译速度有点慢</code>,<code>git下载速度慢</code>,<code>系统资源占用比较多</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单的说，Windows的系统盘被挂载到了&lt;code&gt;/mnt&lt;/code&gt;目录下,&lt;/p&gt;
&lt;p&gt;我们用命令 &lt;code&gt;wsl&lt;/code&gt; 系统安装的linux子系统, 使用 &lt;code&gt;cd /mnt&lt;/code&gt; 切换到对应的目录, 使用&lt;code&gt;ls&lt;/cod
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>社会契约论经典</title>
    <link href="https://binyon.github.io/2019/02/08/Du%20Contrat%20Social/"/>
    <id>https://binyon.github.io/2019/02/08/Du Contrat Social/</id>
    <published>2019-02-08T13:34:19.000Z</published>
    <updated>2019-02-26T06:22:29.688Z</updated>
    
    <content type="html"><![CDATA[<p>人性首要的法则是要维护自身的生存，人性首要的关怀是对自己的关怀。</p><p>强力导致了奴隶的出现，而怯懦则使他们永远当奴隶。</p><p>为了利益转让自由。纵使人们能够转让自己的权利，但是他也无法转让自己孩子的自由和权利。孩子生来是自由的，他们的自由是属于自己的，任何人都没有权利堆对他们进行处置。只能在孩子清醒作用理智之前父亲可以为了他的生存，幸福，商定某些契约。但是却不能将他们无条件奉送给别人，因为这种奉送违反了自然的目的，而且超出了作为父亲的应有权利。</p><p>放弃自由就等于是放弃了自己作为人的资格，放弃人的权利，甚至是放弃自己的义务。而一个放弃自己义务的人是无法得到任何补偿的。这种弃权是不和人性的，并且取消了意志的自由，也就相当于取消了行为的一切道德性。最后。规定一方为绝对的权威，另一方无条件的服从，这本身就是一项无效且自身矛盾的约定。</p><p>和平是一种状态，人处于原始独立状态的时候，彼此之间绝不存在任何的经常性的关系能够构成和平状态或者战争状态，所以他们绝不可能是天生的仇敌。构成战争的是物而不是人的关系。私下的决斗，斗殴，或者是冲突，这些行为都无法构成一种状。因此战争是一种国与国之间的关系，而非人与人之间的一用关系。在战争中，个人与个人绝非以人的身份，甚至则也不是以公民的身份，而仅仅是以士兵的身份才偶然成为仇敌的，他们只是国家的保卫者，而绝不是作为国家的成员。最后，只要我们不能在性质不同的事物之间确定任何关系，一个国家就不能以人为敌，而只能以其他国家为敌。</p><p>生存危机使人类联合在一起，达成了人类历史上的第一次全体同意，并最终导致了少数服从多数的结果的出现。这就是对社会上存在的少数服从多数的理解。</p><p>一旦人群结成了一个共同体，侵犯其中任何一个成员就被看做是在侵犯整个共同体，而侵犯共同体就使得共同体成员同仇敌忾。如此一来，基于义务和利害的关系就迫使缔约者双方互助，而同时这些人也就应竭力使相关的利益在这种双重关系之下结合在一起。</p><p>个人力量为标志的自然自由，自己被公共意愿约束的社会自由</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;人性首要的法则是要维护自身的生存，人性首要的关怀是对自己的关怀。&lt;/p&gt;
&lt;p&gt;强力导致了奴隶的出现，而怯懦则使他们永远当奴隶。&lt;/p&gt;
&lt;p&gt;为了利益转让自由。纵使人们能够转让自己的权利，但是他也无法转让自己孩子的自由和权利。孩子生来是自由的，他们的自由是属于自己的，任何
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://binyon.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>一篇记录git使用的方法</title>
    <link href="https://binyon.github.io/2019/01/24/git-use/"/>
    <id>https://binyon.github.io/2019/01/24/git-use/</id>
    <published>2019-01-23T17:10:34.000Z</published>
    <updated>2019-02-18T14:39:36.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-是什么"><a href="#Git-是什么" class="headerlink" title="Git 是什么?"></a>Git 是什么?</h2><h2 id="Git-获取安装"><a href="#Git-获取安装" class="headerlink" title="Git 获取安装"></a>Git 获取安装</h2><p>//Todo</p><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p><code>sudo apt-get install git</code></p><h3 id="Windows-7-orhigher"><a href="#Windows-7-orhigher" class="headerlink" title="Windows 7 orhigher"></a>Windows 7 orhigher</h3><p>推荐使用 <code>gitforWindows</code> 提供的git工具,百度搜索第一个就是.</p><h2 id="Git-使用前配置"><a href="#Git-使用前配置" class="headerlink" title="Git 使用前配置"></a>Git 使用前配置</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>Ubuntu 下不需要多余的配置,安装之后打开<code>terminal</code>即可</p><p>Windows下默认安装不需要配置, 直接运行<code>git bash</code>即可.</p><h3 id="Git-初始化"><a href="#Git-初始化" class="headerlink" title="Git 初始化"></a>Git 初始化</h3><p>先创建一个文件夹, 通过命令行的形式 <code>cd your_dir</code> 进入输入命令 <code>git init</code> init表示初始化,表示创建一个空的Git 仓库, 或者是重新初始化一个已经存在的 Git 仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建一个git学习文件夹然后进入</span></span><br><span class="line">$ mkdir git_learn</span><br><span class="line">$ <span class="built_in">cd</span> git_learn</span><br><span class="line"><span class="comment"># 初始化git_learn为一个git仓库</span></span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><h3 id="Git-使用前配置-1"><a href="#Git-使用前配置-1" class="headerlink" title="Git 使用前配置"></a>Git 使用前配置</h3><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/progit.git progit</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> progit</span><br><span class="line"></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="初始化分支"><a href="#初始化分支" class="headerlink" title="初始化分支"></a>初始化分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git init <span class="comment">#运行此命令之后会在当前的目录中出现一个.git文件夹</span></span><br><span class="line"></span><br><span class="line">$ git add *.c *.py <span class="comment"># 把当前目录中的.c,.py文件纳入版本管理系统中。即将其放入暂存区域，把未进行追踪的文件进行追踪</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m <span class="string">"initial project version"</span></span><br></pre></td></tr></table></figure><h2 id="从现有仓库克隆"><a href="#从现有仓库克隆" class="headerlink" title="从现有仓库克隆"></a>从现有仓库克隆</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆远程的hexo仓库，并在本地命名为myhexo</span></span><br><span class="line">$ git <span class="built_in">clone</span> git://github.com/binyon/hexo.git myhexo</span><br><span class="line"></span><br><span class="line">$ git status <span class="comment">#查看当前的状态，有多少个分支，目录，记录</span></span><br><span class="line"></span><br><span class="line">$ git add *.c <span class="comment"># 如果多次修改的话，则需要将其多提add操作，否则它将只会记录你之前提交的那个时间点上的修改。</span></span><br></pre></td></tr></table></figure><h2 id="gitignore-文件"><a href="#gitignore-文件" class="headerlink" title="gitignore 文件"></a>gitignore 文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将不需要追踪的文件放入里面，如 .[oa], .[c]等文件， *~忽略以波浪号结尾的文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明</span></span><br><span class="line"><span class="comment"># 以#开头的或者是空行的都会被忽略, 匹配模式下的跟反斜杠表示要忽略的是目录, 要忽略指定匹配模式以外的文件,在前面加上反引号(!)</span></span><br></pre></td></tr></table></figure><p>举例说明如下</p><pre><code># 这个是注释,将被.git忽略# 忽略所有以.a结尾的文件*.a# 但是lib.a除外!lib.a# 仅仅忽略Todo下的所有文件,但不包括subdir/Todo/Todo# 忽略build目录下的所有文件,build/# 会忽略doc/notes.txt,但是不包括doc/server/server.txtdoc/*.txt# 忽略所有的在doc目录下的txt文件doc/**/*.txt</code></pre><h2 id="git-status-and-git-diff"><a href="#git-status-and-git-diff" class="headerlink" title="git status and git diff"></a>git status and git diff</h2><p>git status仅仅只能列出修改过的文件,但是针对具体的修改了那一部分的话需要使用git diff命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前文件与暂存区中的对照</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看暂存起来的和上次提交之间的差异,也可以使用git diff --staged</span></span><br><span class="line">$ git diff --cached</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交运行,运行此命令将会调用默认的编辑器来编辑提交记录</span></span><br><span class="line">$ git commit</span><br><span class="line"></span><br><span class="line">$ git commit -a <span class="comment">#会将所有已经在追踪过的文件提交,跳过git add环节</span></span><br></pre></td></tr></table></figure><h2 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h2><p>移除文件,就是要将其不要被git追踪,移除之后将会出现在未追踪清单中”changes not staged for commit”部分.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ rm .git</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">$ git status <span class="comment"># 在状态中将会显示deleted : .git</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 记录这次移除</span></span><br><span class="line">$ git rm <span class="string">"filename"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 注意:如果之前在删除之前放入暂存区,则需要使用强制命令,-f删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种情况</span></span><br><span class="line"><span class="comment"># 把文件从git中删除追踪,但是保留之前提交的文件.</span></span><br><span class="line">$ git rm --cached readme.txt</span><br><span class="line">$ git rm <span class="built_in">log</span>/\*.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><h2 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h2><p>说明:git并不追踪文件移动操作.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git mv file_from file_to</span><br><span class="line"></span><br><span class="line"><span class="comment">#说明上面命令相当于运行了以下的三个命令</span></span><br><span class="line">$ mv file_from file_to</span><br><span class="line">$ git rm file_from</span><br><span class="line">$ git add file_to</span><br></pre></td></tr></table></figure><h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><p>在克隆完一个git项目之后至少会有一个origin的远程库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote <span class="comment"># origin</span></span><br><span class="line">$ git remote -v <span class="comment"># -verbose 查看对应的地址</span></span><br></pre></td></tr></table></figure><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git remote add [shortname] [url] <span class="comment"># 用shortname来指代url对应的仓库</span></span><br><span class="line"></span><br><span class="line">$ git fetch [shortname]</span><br></pre></td></tr></table></figure><h3 id="从远程仓库获取数据"><a href="#从远程仓库获取数据" class="headerlink" title="从远程仓库获取数据"></a>从远程仓库获取数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br><span class="line"></span><br><span class="line"><span class="comment">### 注意,下面命令会取得你从上次克隆之后的所有更新文件,但是不会自动合并.</span></span><br><span class="line">$ git fetch origin </span><br><span class="line"></span><br><span class="line">$ git pull <span class="comment">#会自动合并,</span></span><br></pre></td></tr></table></figure><h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认使用origin 和 master</span></span><br><span class="line">$ git push [remote-name] [branch-name]</span><br></pre></td></tr></table></figure><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>语法, <code>git push [远程名] [本地分支]:[远程分支]</code></p><p>如果你想要在服务器上删除远程分支<code>backup</code>,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :backup</span><br></pre></td></tr></table></figure></p><h2 id="创建git分支"><a href="#创建git分支" class="headerlink" title="创建git分支"></a>创建git分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上命令等同于</span></span><br><span class="line">$ git branch backup</span><br><span class="line">$ git checkout backup</span><br><span class="line"></span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge backup <span class="comment"># 合并两个分支</span></span><br><span class="line"></span><br><span class="line">$ git branch -d backup <span class="comment"># 合并之后不需要就删除这个分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并时遇到冲突</span></span><br><span class="line">$ git status <span class="comment">#查看问题出现在哪</span></span><br><span class="line">$ git add <span class="comment">#解决问题之后将其标记为已解决</span></span><br><span class="line">$ git mergetool <span class="comment"># or opendiff，调用默认工具合并</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git-是什么&quot;&gt;&lt;a href=&quot;#Git-是什么&quot; class=&quot;headerlink&quot; title=&quot;Git 是什么?&quot;&gt;&lt;/a&gt;Git 是什么?&lt;/h2&gt;&lt;h2 id=&quot;Git-获取安装&quot;&gt;&lt;a href=&quot;#Git-获取安装&quot; class=&quot;header
      
    
    </summary>
    
      <category term="git" scheme="https://binyon.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://binyon.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Conda 基本使用方法</title>
    <link href="https://binyon.github.io/2019/01/23/conda-use/"/>
    <id>https://binyon.github.io/2019/01/23/conda-use/</id>
    <published>2019-01-23T15:43:36.000Z</published>
    <updated>2019-02-18T14:39:36.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="conda简介"><a href="#conda简介" class="headerlink" title="conda简介"></a>conda简介</h2><h2 id="conda使用"><a href="#conda使用" class="headerlink" title="conda使用"></a>conda使用</h2><ol><li>命令行模式使用</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 查看当前的conda环境</span></span><br><span class="line">conda info -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看conda帮助</span></span><br><span class="line">conda -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看conda下的create帮助</span></span><br><span class="line">conda create -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前的conda环境</span></span><br><span class="line">conda env list</span><br><span class="line"></span><br><span class="line"> <span class="comment">#创建一个3.6版本的conda环境</span></span><br><span class="line">conda create --name Python36 python=3.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活上面创建的conda环境</span></span><br><span class="line">conda activate Python36</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出上面的环境</span></span><br><span class="line">conda deactivate</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除上面创建的conda环境</span></span><br><span class="line">conda remove --name Python36 --all</span><br></pre></td></tr></table></figure><ol start="2"><li><p>anaconda-navigator交互模式使用</p><p> 支持选项比较少，只有create，import和remove三个选项。创建和删除的时候只需要输入环境的名字即可。</p></li></ol><h2 id="conda环境安装位置"><a href="#conda环境安装位置" class="headerlink" title="conda环境安装位置"></a>conda环境安装位置</h2><pre><code>默认在anaconda安装路径下的envs目录下，各个平台都相同。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;conda简介&quot;&gt;&lt;a href=&quot;#conda简介&quot; class=&quot;headerlink&quot; title=&quot;conda简介&quot;&gt;&lt;/a&gt;conda简介&lt;/h2&gt;&lt;h2 id=&quot;conda使用&quot;&gt;&lt;a href=&quot;#conda使用&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Conda" scheme="https://binyon.github.io/categories/Conda/"/>
    
    
      <category term="Conda" scheme="https://binyon.github.io/tags/Conda/"/>
    
      <category term="Python" scheme="https://binyon.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>android-studio 踩坑纪实</title>
    <link href="https://binyon.github.io/2019/01/23/android-studio/"/>
    <id>https://binyon.github.io/2019/01/23/android-studio/</id>
    <published>2019-01-23T14:37:09.000Z</published>
    <updated>2019-02-18T14:39:36.735Z</updated>
    
    <content type="html"><![CDATA[<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>android studio v3.2.1</p><h2 id="Android-studio-初次安装坑"><a href="#Android-studio-初次安装坑" class="headerlink" title="Android studio 初次安装坑"></a>Android studio 初次安装坑</h2><h3 id="下载问题"><a href="#下载问题" class="headerlink" title="下载问题"></a>下载问题</h3><p>在国内，安装Android studio可以说是相当麻烦的，除了要费尽心力去下载Android studio的安装包，还要面对安装Android studio过程中下载Android sdk的麻烦。</p><p>由于是校园网，<strong>支持ipv6</strong>，不知道外面能否直接访问Android官网下载Android studio，就不考虑这一步吧。</p><p>虽然有ipv6加持，但是在安装Android studio过程中还是会遇到<strong>下载Android sdk的问题</strong>，依然是无法访问Google。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li><p>方法一</p><ol><li>github上下载xx-net,按照官方文档安装</li><li>Android studio 提示无法下载的时候，设置proxy代理，代理到xx-net上。host：127.0.0.1，port：8086</li><li>下载安装，会比较慢。<br>注意:这个方法问题比较多,可以尝试方法2. 但是这不失为一种科学上网的方法.</li></ol></li><li><p>方法二</p><p>选择国内镜像, 可以参考如下链接的回答,  <a href="&quot;https://blog.vvzero.com/2018/04/08/set-proxy-for-newest-android-studio/&quot;">国内镜像使用</a>, 主面板右下角的Configure –&gt; settings –&gt; Appearance &amp; Behavior –&gt; System Settings –&gt; HTTP Proxy，选中Auto-detect proxy settings，勾选下方Automatic proxy configuration URL，填入国内的某个镜像站。这里，我选择的是<code>mirrors.neusoft.edu.cn:80</code>。</p></li></ol><h2 id="Android-studio-初次编译坑"><a href="#Android-studio-初次编译坑" class="headerlink" title="Android studio 初次编译坑"></a>Android studio 初次编译坑</h2><p>安装好Android sdk之后还有一个问题，新建helloworld工程之后，要使用<strong>gradle编译</strong>。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><pre><code>如果是使用上面的方法一下载Android sdk，那么遇到gradle编译失败时，需要考虑将代理修改回原本的设置。gradle在配置的时候会默认使用原来的网络代理，且一直使用，这个需要手动修改。因为gradle官网是可以访问的，不需要设置代理，代理之后会出现各种问题。以下为修改方案找到工程下的Gradle的gradle.properties，注释掉：    // 这是我用xx-net代理的配置    systemProp.https.proxyPort=8086    systemProp.http.proxyHost=127.0.0.1    systemProp.https.proxyHost=127.0.0.1    systemProp.http.proxyPort=8086或者是有http代理，但是没有https代理，对应添加https代理</code></pre><h2 id="Android-studio运行坑"><a href="#Android-studio运行坑" class="headerlink" title="Android studio运行坑"></a>Android studio运行坑</h2><p>完成编译之后, 对于初学者来说最重要的是看到我完成了什么, 通过运行可以进一步增加我们的成就感.</p><p>那么在运行项目的时候, 有那些需要注意的呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">电脑内存过小的话, 8 g 起步吧. 就不推荐虚拟机运行,需要下载镜像,这是比较麻烦的,而且运行速度慢,还需要编译</span><br><span class="line">推荐使用电脑usb连接手机, 开启usb调试模式, 直接就在手机上编译运行了,对于编译速度来说相当有保证.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;版本号&quot;&gt;&lt;a href=&quot;#版本号&quot; class=&quot;headerlink&quot; title=&quot;版本号&quot;&gt;&lt;/a&gt;版本号&lt;/h3&gt;&lt;p&gt;android studio v3.2.1&lt;/p&gt;
&lt;h2 id=&quot;Android-studio-初次安装坑&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="android" scheme="https://binyon.github.io/categories/android/"/>
    
    
      <category term="android studio" scheme="https://binyon.github.io/tags/android-studio/"/>
    
      <category term="android" scheme="https://binyon.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Python 再次入门记录</title>
    <link href="https://binyon.github.io/2019/01/23/python-new/"/>
    <id>https://binyon.github.io/2019/01/23/python-new/</id>
    <published>2019-01-23T14:34:24.000Z</published>
    <updated>2019-02-26T06:27:40.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-可以用来干什么"><a href="#Python-可以用来干什么" class="headerlink" title="Python 可以用来干什么"></a>Python 可以用来干什么</h2><ul><li>写网站</li><li>数据分析</li><li>写各种工具</li></ul><h2 id="Python的解释器"><a href="#Python的解释器" class="headerlink" title="Python的解释器"></a>Python的解释器</h2><p>Python有多种解释器。</p><h3 id="Cpython"><a href="#Cpython" class="headerlink" title="Cpython"></a>Cpython</h3><p>其中默认的是cpython，是用c语言写的Python解释器。有历史背景，开发Python这门编程语言的时候，c语言占据了编程世界的主要地位，且运行速度快，更接近硬件底层。所以。</p><p>提示符为： <strong>&gt;&gt;&gt;</strong></p><h3 id="Ipython"><a href="#Ipython" class="headerlink" title="Ipython"></a>Ipython</h3><p>ipython，全称可以理解为interaction python，可以实时展示Python的运行效果。</p><p>提示符为： <strong>ln[序号]：</strong></p><p>== 推荐使用jupyter notebook 记录编码过程和做笔记 ==</p><h3 id="PyPy"><a href="#PyPy" class="headerlink" title="PyPy"></a>PyPy</h3><p>PyPy 是另一个 Python 解释器，它的目标是执行速度。 PyPy 采用 JIT 技术，对 Python 代码进行动态编译（注意不是解释），所以可以显著提高 Python 代码的执行速度。</p><h3 id="Jython"><a href="#Jython" class="headerlink" title="Jython"></a>Jython</h3><p>Jython 是运行在 Java 平台上的 Python 解释器，可以直接把 Python 代码<br>编译成 Java 字节码执行。</p><h3 id="IronPython"><a href="#IronPython" class="headerlink" title="IronPython"></a>IronPython</h3><p>IronPython 和 Jython 类似，只不过 IronPython 是运行在微软.Net 平台上<br>的 Python 解释器，可以直接把 Python 代码编译成.Net 的字节码。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。</p><h2 id="Python-编辑器"><a href="#Python-编辑器" class="headerlink" title="Python 编辑器"></a>Python 编辑器</h2><h3 id="编辑器之争"><a href="#编辑器之争" class="headerlink" title="编辑器之争"></a>编辑器之争</h3><p>对于Python的编辑器有太多选择了, 有各种IDE,还有各种文本编辑器.</p><p>但是对于初学者, 我们需要的是对于Python的基本语法快速熟悉. 不要在细枝末节上做纠结, 导致舍本逐末.</p><p>这里我推荐使用 <code>thonny</code> 这个专门为Python初学者开发的编辑器, 足够简单, 功能也足够强大.</p><h3 id="Thonny"><a href="#Thonny" class="headerlink" title="Thonny"></a>Thonny</h3><ul><li>具备自动补全</li><li>具备一定的debug功能</li><li>可靠的包管理器,集成pip</li><li>集成最新的python3</li><li>有错误建议</li></ul><p>等到该编辑器不够使用之后再进一步学习 ide 的使用吧. (可以使用pycharm)</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出 dog cat pig, 用逗号分割</span></span><br><span class="line">print(<span class="string">'dog '</span> , <span class="string">'cat '</span>, <span class="string">'pig'</span>)</span><br><span class="line"><span class="comment"># 输入</span></span><br><span class="line">youIn = input(<span class="string">"please input some chacter: "</span>)</span><br><span class="line"><span class="comment"># 两种格式化输出方式</span></span><br><span class="line">print(<span class="string">"you input is %s"</span>, youIn)</span><br><span class="line">print(<span class="string">"you input is :%s"</span> % (youIn))</span><br></pre></td></tr></table></figure><h3 id="格式化输出-TODO"><a href="#格式化输出-TODO" class="headerlink" title="格式化输出 TODO"></a>格式化输出 TODO</h3><h3 id="缩进-注释"><a href="#缩进-注释" class="headerlink" title="缩进\注释"></a>缩进\注释</h3><p>缩进一般使用 <code>Tab</code> , 四个空格. 有助于写出格式化的代码,但是当复制代码的时候就很麻烦. 使用ide很难格式化Python的代码.</p><p><code>空格和Tab一定不能混用</code> , 混用之后很麻烦.初学者一般是在这里出错.</p><p>注释</p><ul><li>使用 <code>#</code>, <strong>单行注释</strong>.</li><li>使用三个单引号或双引号, <strong>多行注释</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一条单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">这是几条多行注释,</span></span><br><span class="line"><span class="string">一般用于文件开头,说明作者, 代码意图, 写代码时间等.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">这也是多行注释</span></span><br><span class="line"><span class="string">这也是多上注释</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的两条代码也可以用于多行输出,试试如下代码</span></span><br><span class="line">print(</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">这也是多行注释</span></span><br><span class="line"><span class="string">这也是多上注释</span></span><br><span class="line"><span class="string">"""</span>)</span><br><span class="line">print(<span class="string">'''</span></span><br><span class="line"><span class="string">这是几条多行注释,</span></span><br><span class="line"><span class="string">一般用于文件开头,说明作者, 代码意图, 写代码时间等.</span></span><br><span class="line"><span class="string">'''</span>)</span><br></pre></td></tr></table></figure><h2 id="Python-面向对象编程"><a href="#Python-面向对象编程" class="headerlink" title="Python 面向对象编程"></a>Python 面向对象编程</h2><h3 id="面向对象的概念"><a href="#面向对象的概念" class="headerlink" title="面向对象的概念"></a>面向对象的概念</h3><p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p><p>面向对象程序设计将程序拆分成一系列的命令集合, 为了简化复杂度, 将一个复杂的函数拆分成各种简单的函数. 即 <code>大函数</code> -&gt; <code>小函数</code></p><p>面向对象程序设计将程序拆分成多个对象的组合, 一个对象可以处理另一个对象传递过来的数据.</p><p>Python中所有的数据类型都是对象.</p><h3 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h3><p>面向对象的设计思想是<code>抽象出Class</code>，<code>根据Class创建Instance</code></p><p>面向对象的抽象程度比函数要高, 既包含数据, 也包含处理数据的方法.</p><p>类起一个模板的作用, 必须包含基本的属性.</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="创建一个类的基本方法"><a href="#创建一个类的基本方法" class="headerlink" title="创建一个类的基本方法"></a>创建一个类的基本方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class #表示声明一个类,后面紧跟类名. 类名通产是大写开头.</span><br><span class="line">object <span class="comment"># 表示该类是从那个类继承下来的, 是所有的类都会继承的. 没有明确继承就写object.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本构造</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过__init__ 方法, 绑定属性, 起到模板作用.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># self 表示创建的实例本身</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure><h4 id="处理学生成绩"><a href="#处理学生成绩" class="headerlink" title="处理学生成绩"></a>处理学生成绩</h4><ul><li>函数方式处理对应的数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要处理的数据</span></span><br><span class="line">std1 = &#123;<span class="string">'name'</span>:<span class="string">'Tom'</span>, <span class="string">'score'</span>:<span class="number">81</span>&#125;</span><br><span class="line">std2 = &#123;<span class="string">'name'</span>:<span class="string">'Mac'</span>, <span class="string">'score'</span>:<span class="number">90</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印学生成绩</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_score</span><span class="params">(std)</span>:</span></span><br><span class="line">    print(<span class="string">'%s : %s'</span> % (std[<span class="string">'name'</span>], std[<span class="string">'score'</span>]))</span><br></pre></td></tr></table></figure><ul><li>面向对象思想处理学生成绩实例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line">    <span class="comment"># 函数 -&gt; 类的方法, 调用student类自身的函数, 打印成绩</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_score</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s : %s"</span> % (self.name, self.score) )</span><br><span class="line">    <span class="comment"># 创建一个新方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_grade</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.score &gt;= <span class="number">90</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'A'</span></span><br><span class="line">        <span class="keyword">elif</span> self.score &gt;= <span class="number">60</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'B'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'C'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 面向对象代码, 传入与 __init__ 方法有相同属性的实例.</span></span><br><span class="line">bart = Student(<span class="string">'Bart Simpson'</span>, <span class="number">59</span>)</span><br><span class="line">lisa = Student(<span class="string">'Lisa Simpson'</span>, <span class="number">87</span>)</span><br><span class="line">bart.print_score()</span><br><span class="line">lisa.print_score()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接在外部修改student实例的score属性值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">'Bart Simpson'</span>, <span class="number">59</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lisa = Student(<span class="string">'Lisa Simpson'</span>, <span class="number">87</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.score = <span class="number">50</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.score = <span class="number">70</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制外部代码修改实例的name, score 属性</span></span><br><span class="line"><span class="comment"># 通过双下划线(`__`)将其属性变成私有变量, 以达到拒绝外部访问的效果</span></span><br><span class="line"><span class="comment"># 对于单下划线的变量虽然可以直接访问,但是我们将其视作私有变量, 不要随意访问</span></span><br><span class="line"><span class="comment"># __variable__ 这种变量是特殊变量, 可以直接访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name , score)</span>:</span></span><br><span class="line">    self.__name = name</span><br><span class="line">    self.__score = score</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_score</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'%s :%s'</span> % (self.__name), self.__score)</span><br><span class="line"><span class="comment"># 获取对应的属性值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__name</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.__score</span><br><span class="line"><span class="comment"># 修改内部的属性值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    self.__name = name</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, score)</span>:</span></span><br><span class="line">    self.__score = score</span><br><span class="line"><span class="comment"># 双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart._Student__name</span><br><span class="line"><span class="string">"bart"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意以下的一种错误写法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.__name = <span class="string">'bart 2'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.__name</span><br><span class="line"><span class="string">'bart 2'</span></span><br><span class="line"><span class="comment"># 看似成功修改了__name的属性值, 可是调用如下方法却会发现没有修改</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.get_name()</span><br><span class="line"><span class="string">'bart'</span></span><br></pre></td></tr></table></figure><h3 id="对象-Class-和实例-Instance"><a href="#对象-Class-和实例-Instance" class="headerlink" title="对象(Class)和实例(Instance)"></a>对象(Class)和实例(Instance)</h3><ul><li>对象Class</li></ul><p>即一类事物的合集, 是一种抽象概念. 具有同一特性的一类事物的总称. 如所有的 Student(Class)</p><ul><li>实例Instance</li></ul><p>即一类事物中的一个具体存在的个体, 是实际存在的一个. 如一个叫 Tom(Instance) 的 Student(Class)</p><h3 id="方法和函数的区别"><a href="#方法和函数的区别" class="headerlink" title="方法和函数的区别"></a>方法和函数的区别</h3><p>方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据</p><h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><ul><li>继承</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 假设我们定义了一个Animal类</span></span><br><span class="line"><span class="comment"># 父类, 被继承的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># animal run method</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'animal\'s run...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类,继承自Animal, 所有的对象都继承自object, 自动拥有了父类的所有方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试代码</span></span><br><span class="line">xiaohaung = Dog()</span><br><span class="line"><span class="comment"># 这里我们虽然在dog类中什么都没做, 但是依然具有run方法, 这就是继承</span></span><br><span class="line">xiaohuang.run()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类型检查, 子类可以看做是父类, 但是父类不能看做是子类. </span></span><br><span class="line"><span class="comment"># 比如 黄种人是人, 但是人不一定是黄种人.</span></span><br><span class="line">isinstance(xiaohuang, Animal) <span class="comment"># True</span></span><br><span class="line">isinstance(xiaohuang , Dog) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是</span></span><br><span class="line">animal = Animal()</span><br><span class="line">isinstance(animal, Dog) <span class="comment"># false</span></span><br></pre></td></tr></table></figure><ul><li>多重继承</li></ul><p>对于不同事物，我们有不同的分类，各种分类方式之间可能完全不交叉，也可能有所交叉<br>当我们进行程序设计的时候，如果要给每一个类都进行划分，对于不同的类又有不同的功能。<br>我们很难穷举出所有的分类来。<br>在此我们采用多重继承的方式来解决这个问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>多态</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们重写子类中的run方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"dog is run..."</span>)</span><br><span class="line"></span><br><span class="line">xiaohaung = Dog()</span><br><span class="line">xiaohaung.run()</span><br><span class="line"><span class="comment"># 输出结果表示子类的run方法得到了运行, 父类的没有被运行.</span></span><br><span class="line"><span class="comment"># 因为代码在运行的时候总是会优先使用子类有了的方法.</span></span><br><span class="line"><span class="comment"># 以上是多态的一种</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多态的好处</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_run</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    Animal.run()</span><br><span class="line">    Animal.run()</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="keyword">print</span>)run(xiaohuang)</span><br><span class="line">animal = Animal()</span><br><span class="line">print_run(animal)</span><br></pre></td></tr></table></figure><p>以上例子说明我们不用修改代码, 通过传入不同的类就能获得不同的输出结果.</p><h2 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h2><p>我们拿到一个对象的时候, 如何知道这个对象<strong>是什么类型</strong>, <strong>有什么方法</strong></p><h3 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h3><p>对于<strong>基本类型</strong>, 使用type()函数判断对象类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="number">123</span>), type(<span class="string">'str'</span>)</span><br><span class="line">&lt;class 'int'&gt;, &lt;class 'str'&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(int), type(str)</span><br><span class="line">&lt;class 'type'&gt;, &lt;classs 'type'&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="keyword">None</span>)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">NoneType</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"># 对于内置的函数</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(abs)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">builtin_function_or_method</span>'&gt;</span></span><br></pre></td></tr></table></figure><h3 id="判断一个对象是否是函数-可以用一个types库中的函数"><a href="#判断一个对象是否是函数-可以用一个types库中的函数" class="headerlink" title="判断一个对象是否是函数, 可以用一个types库中的函数"></a>判断一个对象是否是函数, 可以用一个types库中的函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> types</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 自定义函数类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(fn) == types.FunctionType</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># 内置函数类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(abs) == types.BuiltinFunctionType</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)) == types.GeneratorType</span><br></pre></td></tr></table></figure><h3 id="对于类的继承关系来讲-使用isinstance"><a href="#对于类的继承关系来讲-使用isinstance" class="headerlink" title="对于类的继承关系来讲, 使用isinstance()"></a>对于类的继承关系来讲, 使用isinstance()</h3><p>object -&gt; Person -&gt; YellowPerson -&gt; SichuanPerson</p><p>使用isinstance() 可以判断继承关系, 也可以替代type()函数, 所以我们总是优先使用isinstance().</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断基本类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'123'</span>, str)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">123</span>, int)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断变量是否是多个类别中的一种</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([<span class="number">12</span>,<span class="number">3</span>], (tuple, list))</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;<span class="string">'name'</span>:bin, <span class="string">'age'</span>:<span class="number">12</span>&#125;, (dict, list))</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断继承关系</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I'm a person"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YellowPerson</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I'm a yellowperson"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SichuanPerson</span><span class="params">(YellowPerson)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I'm a sichuanperson"</span>)</span><br><span class="line">        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person = Person()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>yellowPerson = YellowPerson()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sichuan = SichuanPerson()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person.say()</span><br><span class="line">I<span class="string">'m a person</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; yellowPerson.say</span></span><br><span class="line"><span class="string">&lt;bound method YellowPerson.say of &lt;__main__.YellowPerson object at 0x7f3f4d2de630&gt;&gt;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; yellowPerson.say()</span></span><br><span class="line"><span class="string">I'</span>m a yellowperson</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sichuan.say()</span><br><span class="line">I<span class="string">'m a sichuanperson</span></span><br></pre></td></tr></table></figure><h3 id="使用dir"><a href="#使用dir" class="headerlink" title="使用dir()"></a>使用dir()</h3><p>dir() 用于获得对象的所有方法和属性. 尤其是当不知道对象具有什么属性的时候<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(person) <span class="comment"># 一长串, 自定义的方法出现在最后</span></span><br><span class="line"><span class="comment"># 配合hasattr(), getattr(), setattr() 函数, 可以很方便的为对象添加属性和方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个完整演示 dir(), hasattr(), getattr(), setattr()的例子</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyPower</span><span class="params">(int)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.x * self.x</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = MyPower(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.power()</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'x'</span>) <span class="comment"># obj 有x属性吗</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'x'</span>) <span class="comment"># obj</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'x'</span>) <span class="comment"># 获取obj.x对应的属性值, 如果没有这个属性则会报错</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>setattr(obj, <span class="string">'y'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: setattr expected <span class="number">3</span> arguments, got <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>setattr(obj, <span class="string">'y'</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>setattr(obj, <span class="string">'y'</span>, <span class="number">12</span>) <span class="comment"># 设置obj的属性值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'y'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'y'</span>)</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(obj) <span class="comment">#列出obj的所有属性和方法</span></span><br><span class="line">[<span class="string">'__abs__'</span>, <span class="string">'__add__'</span>, <span class="string">'__and__'</span>, <span class="string">'__bool__'</span>, <span class="string">'__ceil__'</span>, <span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__divmod__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__float__'</span>, <span class="string">'__floor__'</span>, <span class="string">'__floordiv__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__getnewargs__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__index__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__int__'</span>, <span class="string">'__invert__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lshift__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__mod__'</span>, <span class="string">'__module__'</span>, <span class="string">'__mul__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__neg__'</span>, <span class="string">'__new__'</span>, <span class="string">'__or__'</span>, <span class="string">'__pos__'</span>, <span class="string">'__pow__'</span>, <span class="string">'__radd__'</span>, <span class="string">'__rand__'</span>, <span class="string">'__rdivmod__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__rfloordiv__'</span>, <span class="string">'__rlshift__'</span>, <span class="string">'__rmod__'</span>, <span class="string">'__rmul__'</span>, <span class="string">'__ror__'</span>, <span class="string">'__round__'</span>, <span class="string">'__rpow__'</span>, <span class="string">'__rrshift__'</span>, <span class="string">'__rshift__'</span>, <span class="string">'__rsub__'</span>, <span class="string">'__rtruediv__'</span>, <span class="string">'__rxor__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__sub__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__truediv__'</span>, <span class="string">'__trunc__'</span>, <span class="string">'__xor__'</span>, <span class="string">'bit_length'</span>, <span class="string">'conjugate'</span>, <span class="string">'denominator'</span>, <span class="string">'from_bytes'</span>, <span class="string">'imag'</span>, <span class="string">'numerator'</span>, <span class="string">'power'</span>, <span class="string">'real'</span>, <span class="string">'to_bytes'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(obj) <span class="comment">#列出obj的所有属性和方法</span></span><br></pre></td></tr></table></figure></p><h2 id="Python-面向对象高级"><a href="#Python-面向对象高级" class="headerlink" title="Python 面向对象高级"></a>Python 面向对象高级</h2><h3 id="给实例增加属性和方法"><a href="#给实例增加属性和方法" class="headerlink" title="给实例增加属性和方法"></a>给实例增加属性和方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正常情况下我们创建了一个class类，由于动态语言的灵活性</span></span><br><span class="line"><span class="comment">#我们可以给其实例添加任何属性和方法。具体如下</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="comment"># 给实例添加属性</span></span><br><span class="line">s1 = Student()</span><br><span class="line">s1.name = <span class="string">'bing'</span></span><br><span class="line">s1.age = <span class="number">12</span></span><br><span class="line"><span class="comment"># 打印输出对应的名字和年纪</span></span><br><span class="line">print(s1.name, s1.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给实例添加方法</span></span><br><span class="line"><span class="comment"># 先定义一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, score)</span>:</span></span><br><span class="line">    self.score = score</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line"><span class="comment"># 绑定方法</span></span><br><span class="line">s1.set_score = MethodType(set_score, s1)</span><br><span class="line">s1.set_score(<span class="number">90</span>)</span><br><span class="line">print(s1.score)</span><br></pre></td></tr></table></figure><p><code>注意：</code>以上方法绑定的属性和方法，只适用于当前生成的实例，不适用于新创建的实例。</p><h3 id="给对象增加属性和方法"><a href="#给对象增加属性和方法" class="headerlink" title="给对象增加属性和方法"></a>给对象增加属性和方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_gender</span><span class="params">(self, gender)</span>:</span></span><br><span class="line">    self.gender = gender</span><br><span class="line"><span class="comment"># 给类绑定属性和方法</span></span><br><span class="line">Student.set_gender = set_gender</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">s2 = Student()</span><br><span class="line">s2.gender = <span class="string">'male'</span></span><br><span class="line">print(s2.gender)</span><br><span class="line"><span class="comment"># =&gt; 输出为 male</span></span><br></pre></td></tr></table></figure><h3 id="限制实例的属性"><a href="#限制实例的属性" class="headerlink" title="限制实例的属性"></a>限制实例的属性</h3><p>有的时候我们不想要让一个实例,随便添加任何的属性的.这个时候我们可以用<strong>slot</strong>方法来限制创建的实例的属性.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 限制实例的属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_slots</span><span class="params">(object)</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'gender'</span>) <span class="comment"># 使用tuple方式限制实例的属性名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line"><span class="comment"># 创建新实例</span></span><br><span class="line"></span><br><span class="line">s3 = Student_slot()</span><br><span class="line">s3.name = <span class="string">'bing'</span></span><br><span class="line">s3.age = <span class="number">12</span></span><br><span class="line">s3.gender = <span class="string">'male'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多出来的属性,会抛出异常  AttributeError</span></span><br><span class="line">s3.score = <span class="number">90</span></span><br><span class="line"><span class="comment"># print(s3.score)</span></span><br></pre></td></tr></table></figure><p><code>注意:</code> <strong>slots</strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的</p><h3 id="对于属性的保护"><a href="#对于属性的保护" class="headerlink" title="对于属性的保护"></a>对于属性的保护</h3><p>两种方法.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种方法,通过get_attr, set_attr的方式来限制对于属性的访问</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_limit</span><span class="params">(object)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, score)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(score, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"score is not a integer"</span>)</span><br><span class="line">        <span class="keyword">if</span> score &lt; <span class="number">0</span> <span class="keyword">or</span> score &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"the score is out of range"</span>)</span><br><span class="line">        self.__score = score</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line"></span><br><span class="line">s4 = Student_limit()</span><br><span class="line">s4.set_score(<span class="number">100</span>)</span><br><span class="line">print(s4.get_score())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种方法, Python内置的装饰器</span></span><br><span class="line"><span class="comment"># 相对与第一种方法,更加简便</span></span><br><span class="line"><span class="comment"># Python内置的@property装饰器就是负责把一个方法变成属性调用的</span></span><br><span class="line"><span class="comment"># 把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student_limit2</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"the value is not a integer"</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"the value is out of range"</span>)</span><br><span class="line">        self.__score = value</span><br><span class="line"></span><br><span class="line">s5 = Student_limit2()</span><br><span class="line">s5.score = <span class="number">60</span> <span class="comment"># 实际转化为s5.set_score(60)</span></span><br><span class="line">print(s5.score) <span class="comment"># 实际转化为s5.get_score()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过该方法还可以制定只读属性, 只定义getter方法,不定义setter方法</span></span><br></pre></td></tr></table></figure></p><h2 id="一个完整的类"><a href="#一个完整的类" class="headerlink" title="一个完整的类"></a>一个完整的类</h2><p>我们以学生类为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 学生类继承自object类，所有的类都继承自object，学生类也可以继承自Person类，Primary类, 如class Student(Primary):</span></span><br><span class="line"><span class="comment"># 如果使用多个类继承则为多重继承，具有多个类的功能，如class Student(Person, Primary)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span> </span><br><span class="line">    <span class="comment"># 初始化实例</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, id, gender)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__id = id</span><br><span class="line">        self.__gender = gender</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student's object's name &#123;&#125;"</span>.format(self.__name)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python-可以用来干什么&quot;&gt;&lt;a href=&quot;#Python-可以用来干什么&quot; class=&quot;headerlink&quot; title=&quot;Python 可以用来干什么&quot;&gt;&lt;/a&gt;Python 可以用来干什么&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;写网站&lt;/li&gt;
&lt;li&gt;数据分
      
    
    </summary>
    
      <category term="Python" scheme="https://binyon.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://binyon.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>常识经典</title>
    <link href="https://binyon.github.io/2019/01/21/common%20sense/"/>
    <id>https://binyon.github.io/2019/01/21/common sense/</id>
    <published>2019-01-21T13:36:51.000Z</published>
    <updated>2019-02-26T06:21:07.644Z</updated>
    
    <content type="html"><![CDATA[<p>托马斯　潘恩 </p><p>英裔美国思想家、作家、政治活动家、理论家、革命家、激进民主主义者。1737年出生于英格兰，1774年在富兰克林的帮助下到达北美大陆，积极投身于北美的独立事业，并在1776你那以“一个英国人”的署名发表了《常识》。此书极大地鼓舞了北美民众的独立情绪，他也被视为美国开过元勋之一。有中译本将该书评价为“全世界第一本真正的畅销书”。1792年，潘恩被选入法国国民工会。1802年在杰弗逊总统的邀请下，返回美国。却因强硬的反宗教立场，不幸受尽攻击，最终于1809年6月8日在纽约去世，享年72岁。</p><h2 id="谈政府的起源和目的"><a href="#谈政府的起源和目的" class="headerlink" title="谈政府的起源和目的"></a>谈政府的起源和目的</h2><ul><li>一些作家把政府和社会混为一谈，认为他们之间有很少或者没有区别；然而，他们不仅有区别，甚至有着不同的起源。社会因我们的需要产生，政府则由我们的罪恶出现；前者通过汇聚我们的感情来从正面提升我们的幸福，后者则通过限制我们的罪恶来从反面提升我们的幸福。一个鼓励交流，一个制造差别。前者扮演守护者的角色，后者则处在惩罚者的位置。 </li><li>社会在任何情况下都是人民的福祉，然而政府，即使是在最好的状态，也不过是一个无法避免的恶魔，在其最坏的状态时，则令人无法忍受。当我们遭受痛苦，或遭受政府带来的同等痛苦时，或许痛苦我们也会在无政府的国建遇到，然而想到忍受的痛苦是自己一手造成，我们的不幸显得更加悲惨。政府如同衣服，是已失去纯真的象征；像构建在天堂凉亭废墟之上的国王宫殿。因为当良心的推动是明确、统一、不可抗拒且必须服从时，人便不需要立法者；但是如果情况不是这般，人便发现有必要牺牲一点自己的财产来提供保护他人财产的手段；而且就像在其他情形中一样，审慎诱导人们两害相权取其轻。 </li><li>因此，安全保障是政府设立始末的真正目的，毫无疑问，用最低的成本、最大的利润以无论什么方式保障人民安全的政府是所有人所青睐的。 </li><li><p>除了固若金汤的天国之外，万物皆有衍生罪恶的可能，而罪恶也将不可避免地发生，它会随着人们客服移民之初遇到的困难而成比例地攀升。正是这一原因将人们团结在一起，他们开始玩忽职守，开始懈怠对彼此的依赖，而且，这种疏忽表明，很有必要通过建立某种形式的政府来弥补道德上的缺陷。 </p></li><li><p>也就是说，政府管理模式的诞生是因伦理道德已无力统治世界，而且这也是政府的设计和目的，即自由和安全。尽管白雪可能会刺到我们的眼睛，尽管声音可能会欺骗我们的耳朵，尽管偏见可能会扭曲我们的意志，甚至利益会模糊我们的理解力，但是自然和理性却用最朴素的声音高数世人，这一切没错。 </p></li><li><p>一件事情越是简单，它就越不容易出问题，及时出现问题后也越容易修复。基于这一真理，我针对备受吹嘘的英国政体谈一谈自己的想法。在黑暗奴隶制时代诞生的英国政体，就当时来说，是顺应时代需求。在整个世界都处于专制统治下，任何尝试改变这一现状的行为都是伟大的。<br>专制政府（尽管违背人的本性）自身也有优点，那就是，这种形式很简单。如果人们遭受痛苦，它便会知道导致人民痛苦的源头，知道如何解决，也不会迷茫于各种各样的原因以及解决办法中。 </p></li><li>最美的辞藻如若用来描述那些要么不存在的失误，要么描述那些无法用言语表达的复杂事物，他们只不过是具有声音的词语而已。 就像一个迷恋嫖娼的男人无法正确选择或者评价自己的妻子一样，任何偏爱政府腐朽体制先入为主的思想将不能够让我们发现一个优良的体制。<h2 id="谈君主制和世袭制"><a href="#谈君主制和世袭制" class="headerlink" title="谈君主制和世袭制"></a>谈君主制和世袭制</h2></li></ul><ol><li>就上帝造人的顺序来讲，人是生而平等的，之后后来的环境才可以打破这种平等。贫富差距，或许在很大程度上会被计算在内，且不用求助于压迫和贪婪，他们的名字听起来是那么的刺耳。压迫总是结果，很少或者从来不曾是财富的手段；尽管贪婪会让人远离极度的贫困，但是它也总是让人在争取财富是变得胆小如鼠。 </li><li>然而没有任何真正的自然或者是宗教原因可以解释为何君臣有别。男女确实性质有别，好坏自有上帝来分。但人类种族如何来到世界诶你凌驾于万物之上，如何作为新的物种超凡出群，以及它们对人类来说不知是乐还是苦的手段，这些都值得探讨。 </li><li>当一个人深思人们给君主的偶像崇拜时，无需疑惑，提起上帝，哪怕你曾经季度他的荣耀，他不应该赞成任何一种形式的政府，因为这如此不虔诚地侵害了天堂的特权。 </li><li>很多人恐惧而选择向世袭制投降，一些人因迷信而屈服，而最强势的那部分人却和国王联手一并欺压百姓。 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;托马斯　潘恩 &lt;/p&gt;
&lt;p&gt;英裔美国思想家、作家、政治活动家、理论家、革命家、激进民主主义者。1737年出生于英格兰，1774年在富兰克林的帮助下到达北美大陆，积极投身于北美的独立事业，并在1776你那以“一个英国人”的署名发表了《常识》。此书极大地鼓舞了北美民众的独立情
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://binyon.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>数学史概论</title>
    <link href="https://binyon.github.io/2019/01/16/math-history/"/>
    <id>https://binyon.github.io/2019/01/16/math-history/</id>
    <published>2019-01-16T07:48:18.000Z</published>
    <updated>2019-02-18T14:39:36.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学史——人类文明史的重要篇章"><a href="#数学史——人类文明史的重要篇章" class="headerlink" title="数学史——人类文明史的重要篇章"></a>数学史——人类文明史的重要篇章</h1><pre><code>了解历史的变化是了解这门科学的一个步骤——陈省身</code></pre><h2 id="数学史的意义"><a href="#数学史的意义" class="headerlink" title="数学史的意义"></a>数学史的意义</h2><p>数学史对于深刻理解作为科学本身的数学，还是全面了解整个人类文明的发展都具有重要意义。</p><p>不了解数学史，就不可能全面了解整个人类文明史。</p><pre><code>莱布尼茨说，“知道重大发明特别是那些绝非偶然的、经过深思熟虑而得到的重大发明的真正起源是很有益的。这不仅仅在于历史可以给每一个发明者应该有的评价，从而鼓舞其他人去争取同样的荣誉，而且还在于通过一些光辉的返利可以促进发现的艺术，解释发现的方法。”庞加莱说，“如果我们希望预知数学的将来，适当的途径是研究这门学科的历史和现状。” 庞加莱[1854-1912]，被称作是最后一位数学通才。希尔伯特[1862-1943]，“数学科学是一个不可分割的整体，它的生命力正式在于各个部分之间的联系“。</code></pre><ul><li>数学是-一门历史性或积累性很强的科学，如数的理论的演进；非欧几何对于欧式几何的拓宽等。</li></ul><p>数学在人类文明史上有特殊的地位，是由数学作为一种文化的特点决定的。</p><pre><code>首先，数学是以抽象的，追求高度精确、可靠的知识。其次，对于一般性模式的追求，使数学具有广泛的适用性。三角形的面积公式，微积分的创立作为解一般性的无限小算法的结果。同一组偏微分方程可以用于解流体动态，在弹性力学中用来描写振动过程，在声学中用来描述声音的传播等。最后，数学作为一种创造性活动，还具有艺术特征，这就是对美的追求。英国数学家和哲学家罗素说，“数学不仅拥有真理，而且还有至高无上的美——一种冷峻严肃的美，就像是一尊雕像。这种美没有绘画或音乐那样华丽的装饰，它可以纯洁到崇高的程度，能够达到严格的只有最伟大的艺术才能显示的完美境界。”</code></pre><h2 id="什么是数学"><a href="#什么是数学" class="headerlink" title="什么是数学"></a>什么是数学</h2><p>数学本身是一个历史概念，数学的内涵随着时代的变化而变化，给数学下一个一劳永逸的定义是不可能的。</p><p>数学是量的科学。<br>数学是研究现实世界的空间形式与数量关系的科学。<br>现代数学就是各种量之间的可能的，一般说是各种变化着的量的关系和相互联系的数学。</p><h2 id="关于数学历史的分期"><a href="#关于数学历史的分期" class="headerlink" title="关于数学历史的分期"></a>关于数学历史的分期</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数学史——人类文明史的重要篇章&quot;&gt;&lt;a href=&quot;#数学史——人类文明史的重要篇章&quot; class=&quot;headerlink&quot; title=&quot;数学史——人类文明史的重要篇章&quot;&gt;&lt;/a&gt;数学史——人类文明史的重要篇章&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;了解历史的变化是了解
      
    
    </summary>
    
      <category term="Math" scheme="https://binyon.github.io/categories/Math/"/>
    
    
      <category term="Math" scheme="https://binyon.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>python-urllib库学习</title>
    <link href="https://binyon.github.io/2019/01/04/python-urllib/"/>
    <id>https://binyon.github.io/2019/01/04/python-urllib/</id>
    <published>2019-01-04T14:18:17.000Z</published>
    <updated>2019-02-18T14:39:36.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是urllib库"><a href="#什么是urllib库" class="headerlink" title="什么是urllib库"></a>什么是urllib库</h2><ul><li>Python内置的一个库</li><li>urllib.request 请求模块</li><li>urllib.error 异常模块</li><li>urllib.parse url解析库</li><li>urllib.robotparser robot.text解析的库</li></ul><h2 id="Python3相对于Python2的变化"><a href="#Python3相对于Python2的变化" class="headerlink" title="Python3相对于Python2的变化"></a>Python3相对于Python2的变化</h2><p>python2<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line">response = urllib.urlopen(<span class="string">"http://www.baidu.com"</span>)</span><br></pre></td></tr></table></figure></p><p>python3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">response = urllib.request.urlopen(<span class="string">"http://www.baidu.com"</span>)</span><br></pre></td></tr></table></figure><pre><code>注意：requests 以urllib为基础实现的</code></pre><h2 id="urllib-request"><a href="#urllib-request" class="headerlink" title="urllib.request"></a>urllib.request</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出 urllib.request 的帮助文档，help(urllib.request)，如下</span></span><br><span class="line">urlopen(url, data=<span class="keyword">None</span>, timeout=&lt;object object at <span class="number">0x7f66eab220c0</span>&gt;, *, cafile=<span class="keyword">None</span>, capath=<span class="keyword">None</span>, cadefault=<span class="keyword">False</span>, context=<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://httpbin.org"</span></span><br><span class="line">response = urllib.request.urlopen(url = url + str(<span class="string">'get'</span>),timeout = <span class="number">2</span>)</span><br><span class="line">print(response.read())</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = urllib.request.urlopen(url = url+str(<span class="string">'get'</span>),timeout = <span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">if</span> isinstance(e.reason, socket.timeout):</span><br><span class="line">        print(<span class="string">"timeout error"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造一个Request对象</span></span><br><span class="line">request = urllib.request.Request(<span class="string">"http://httpbin.org/"</span>)</span><br><span class="line"><span class="comment">#请求对应的网站</span></span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line"><span class="comment"># 以utf8形式解码</span></span><br><span class="line">print(response.read().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 另外一个实例</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,parse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求网址</span></span><br><span class="line">url = <span class="string">"http://httpbin.org/post"</span></span><br><span class="line"><span class="comment"># 头部信息</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36'</span>,</span><br><span class="line">    <span class="string">'Host'</span>:<span class="string">'httpbin.org'</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">## post 请求字段</span></span><br><span class="line">dict = &#123;</span><br><span class="line">    <span class="string">"name"</span>:<span class="string">"bingwu"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = bytes(parse.urlencode(dict), encoding = <span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">req = request.Request(url = url,headers = headers, data = data, method = <span class="string">'POST'</span>)</span><br><span class="line">res = request.urlopen(req)</span><br><span class="line">print(res.read().decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># add_header 方法</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line"></span><br><span class="line">mydict = &#123;</span><br><span class="line">        <span class="string">'name'</span>:<span class="string">'bingwu'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">data = bytes(parse.urlencode(mydict),encoding = <span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">req = request.Request(url = url, data = data, method = <span class="string">"POST"</span>)</span><br><span class="line">req.add_header(<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36'</span>)</span><br><span class="line"></span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(<span class="string">'utf8'</span>))</span><br></pre></td></tr></table></figure><h2 id="Handler-代理"><a href="#Handler-代理" class="headerlink" title="Handler 代理"></a>Handler 代理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造一个hanler对象，并创建http和https代理,用于伪装不同的ip，以防止爬虫被封</span></span><br><span class="line">proxy_handler = urllib.request.ProxyHandler(&#123;</span><br><span class="line">    <span class="string">'http'</span>:<span class="string">'http://127.0.0.1:8086'</span>,</span><br><span class="line">    <span class="string">'https'</span>:<span class="string">'https://127.0.0.1:8086'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">opener = urllib.request.builder_opener(proxy_handler)</span><br><span class="line">response = opener.open(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line"></span><br><span class="line">print(response.read())</span><br></pre></td></tr></table></figure><h2 id="Cookie-用于维持爬虫登录的一个机制"><a href="#Cookie-用于维持爬虫登录的一个机制" class="headerlink" title="Cookie 用于维持爬虫登录的一个机制"></a>Cookie 用于维持爬虫登录的一个机制</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#实例1</span></span><br><span class="line"><span class="keyword">import</span> urllib.request, http.cookiejar</span><br><span class="line"></span><br><span class="line">cookie = http.cookiejar.CookieJar()</span><br><span class="line"></span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line"></span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line"></span><br><span class="line">response = opener.open(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> cookie:</span><br><span class="line">    print(item.name + <span class="string">'='</span> + item.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例2</span></span><br><span class="line"><span class="keyword">import</span> urllib.request, http.cookiejar</span><br><span class="line"></span><br><span class="line">filename = <span class="string">'cookie.txt'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将cookie保存成Mozilla的格式</span></span><br><span class="line"><span class="comment">#也可以将LWPC格式的cookie</span></span><br><span class="line"></span><br><span class="line">cookie = http.cookiejar.MozillaCookieJar(filename)</span><br><span class="line"></span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line"></span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line"></span><br><span class="line">response = opener.open(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line"></span><br><span class="line">cookie.save(ignore_discard=<span class="keyword">True</span>, ignore_expires=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取cookie文件中的内容，并输出</span></span><br><span class="line">cookie.load(<span class="string">'cookie.txt'</span>,ignore_discard=<span class="keyword">True</span>, ignore_expires=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">openr = urllib.request.build_opener(handler)</span><br><span class="line"></span><br><span class="line">response = opener.open(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">print(response.read().decode(<span class="string">'utf8'</span>))</span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 验证 error 的错误类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib.request, urllib.error</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = urllib.request.urlopen(<span class="string">'http://binyong.github.io/dajkdaj.html'</span>)</span><br><span class="line"><span class="keyword">except</span> urllib.error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason, e.code, e.headers, sep = <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    print(<span class="string">'success'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证 error 的错误类型</span></span><br><span class="line"><span class="keyword">import</span> urllib.request, urllib.error</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = urllib.request.urlopen(<span class="string">'http://binyong.github.io/dajkdaj.html'</span>)</span><br><span class="line"><span class="keyword">except</span> urllib.error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason, e.code, e.headers, sep = <span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(e.reason)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    print(<span class="string">'success'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证 error 的错误类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = urllib.request.urlopen(<span class="string">"http://www.baidu.com"</span>,timeout=<span class="number">0.01</span>)</span><br><span class="line"><span class="keyword">except</span> urllib.error.URLError <span class="keyword">as</span> e:</span><br><span class="line">    print(type(e.reason))</span><br><span class="line">    <span class="keyword">if</span> isinstance(e.reason, socket.timeout):</span><br><span class="line">        print(<span class="string">'time out'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是urllib库&quot;&gt;&lt;a href=&quot;#什么是urllib库&quot; class=&quot;headerlink&quot; title=&quot;什么是urllib库&quot;&gt;&lt;/a&gt;什么是urllib库&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Python内置的一个库&lt;/li&gt;
&lt;li&gt;urllib.req
      
    
    </summary>
    
      <category term="Python" scheme="https://binyon.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://binyon.github.io/tags/Python/"/>
    
      <category term="urllib" scheme="https://binyon.github.io/tags/urllib/"/>
    
  </entry>
  
  <entry>
    <title>Python 爬虫基本原理</title>
    <link href="https://binyon.github.io/2019/01/04/Python-crawler-fundamentals/"/>
    <id>https://binyon.github.io/2019/01/04/Python-crawler-fundamentals/</id>
    <published>2019-01-03T16:06:33.000Z</published>
    <updated>2019-02-18T14:39:36.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是爬虫"><a href="#什么是爬虫" class="headerlink" title="什么是爬虫"></a>什么是爬虫</h2><p><strong>请求</strong>网站并<strong>提取</strong>数据的<strong>自动化</strong>程序</p><h2 id="爬虫基本流程"><a href="#爬虫基本流程" class="headerlink" title="爬虫基本流程"></a>爬虫基本流程</h2><h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><pre><code>通过http向目标站点发起请求，发送一个request，可以保护额外的header等信息（一般是必要的，不然会被检测出来）</code></pre><h3 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h3><pre><code>返回一个response，其中内容便是想要获取的页面内容，如html代码，json字符串，二进制数据（图片视频）</code></pre><h3 id="解析内容"><a href="#解析内容" class="headerlink" title="解析内容"></a>解析内容</h3><pre><code>得到的内容可能是html，用正则表达式匹配，json，直接转为json对象解析，二进制数据则保存进一步处理。</code></pre><h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><pre><code>可以存为文本，或者存储到数据库中，可以指定保存文件的格式</code></pre><h2 id="什么是request和response"><a href="#什么是request和response" class="headerlink" title="什么是request和response"></a>什么是request和response</h2><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><ol><li><p>请求方式，最常用的为get，post</p><ul><li>get</li><li>post 包含一个Form data，主要用于登录</li><li>head</li><li>put</li><li>delete</li><li>options</li><li>等</li></ul></li><li>请求url<br>url，统一资源定位符的简称。</li><li>请求头<br>包含了请求时的头部信息，如<strong>user-agent</strong>, host,cookies等</li><li>请求体<br>请求时额外携带的数据，如请求的表单数据，在做post请求的时候需要。</li></ol><h3 id="Respons"><a href="#Respons" class="headerlink" title="Respons"></a>Respons</h3><ol><li><p>响应状态</p><ul><li>200 表示成功</li><li>301 跳转</li><li>404 找不到页面</li><li>502 服务器错误</li></ul></li><li><p>响应头</p><ul><li>内容类型</li><li>内容长度</li><li>服务器信息</li><li>设置cookie等</li></ul></li><li><p><strong>响应体</strong></p><ul><li>包含请求资源的内容</li><li>图片</li><li>二进制数据</li><li>HTML等</li></ul></li></ol><h2 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line"><span class="comment"># 修改编码格式，解决命令行中可能会出现乱码的问题</span></span><br><span class="line">response.encoding = <span class="string">'utf-8'</span></span><br><span class="line">print(response.text)</span><br><span class="line">print(response.headers)</span><br><span class="line">print(response.status_code)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;!-- 构造请求头 --&gt;</span></span><br><span class="line">headers = &#123;&#125;</span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36'</span>&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">"http://www.baidu.com"</span>,headers = headers)</span><br></pre></td></tr></table></figure><h2 id="能抓取怎样的信息"><a href="#能抓取怎样的信息" class="headerlink" title="能抓取怎样的信息"></a>能抓取怎样的信息</h2><ol><li>网页文本</li><li><p>图片，二进制文件保存为图片即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">response = requests.get(<span class="string">"https://www.baidu.com/img/baidu_jgylogo3.gif"</span>)</span><br><span class="line"><span class="comment"># 输出二进制文件的内容</span></span><br><span class="line">print(response.content)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/tmp/1.gif'</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">     f.write(response.content)</span><br><span class="line">     f.close()</span><br></pre></td></tr></table></figure></li><li><p>视频</p></li><li>其他文件</li></ol><h2 id="解析方式"><a href="#解析方式" class="headerlink" title="解析方式"></a>解析方式</h2><ol><li>直接解析</li><li>json解析</li><li>正则表达式</li><li>beautifulsoup</li><li>pyquery</li><li>xpath</li></ol><h2 id="怎样解决JavaScript渲染问题"><a href="#怎样解决JavaScript渲染问题" class="headerlink" title="怎样解决JavaScript渲染问题"></a>怎样解决JavaScript渲染问题</h2><ol><li>分析ajax请求-返回json数据</li><li><p>selenium/webdriver模拟浏览器请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">"http://m.weibo.com"</span>)</span><br></pre></td></tr></table></figure></li><li><p>splash,类似于selenium模拟解析</p></li><li>PyV8,Ghost.py</li></ol><h2 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h2><ol><li>文本</li><li>关系型数据库，MySQL等，具有特定存储内容的一个数据库</li><li>非关系型数据库，如redis，mogodb等key-value形式</li><li>二进制文件，直接存储二进制文件即可</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是爬虫&quot;&gt;&lt;a href=&quot;#什么是爬虫&quot; class=&quot;headerlink&quot; title=&quot;什么是爬虫&quot;&gt;&lt;/a&gt;什么是爬虫&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;请求&lt;/strong&gt;网站并&lt;strong&gt;提取&lt;/strong&gt;数据的&lt;strong&gt;自动化&lt;/s
      
    
    </summary>
    
      <category term="爬虫" scheme="https://binyon.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Python" scheme="https://binyon.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://binyon.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="https://binyon.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据分析环境搭建</title>
    <link href="https://binyon.github.io/2018/12/31/python-analysis-environment/"/>
    <id>https://binyon.github.io/2018/12/31/python-analysis-environment/</id>
    <published>2018-12-31T06:34:04.000Z</published>
    <updated>2019-02-18T14:39:36.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python基本环境搭建（Ubuntu16-04环境下）"><a href="#Python基本环境搭建（Ubuntu16-04环境下）" class="headerlink" title="Python基本环境搭建（Ubuntu16.04环境下）"></a>Python基本环境搭建（Ubuntu16.04环境下）</h1><h2 id="Redis-数据库"><a href="#Redis-数据库" class="headerlink" title="Redis 数据库"></a>Redis 数据库</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ sudo apt install redis-server</span><br></pre></td></tr></table></figure><p>完成安装即可</p><h3 id="Redis-配置文件的修改"><a href="#Redis-配置文件的修改" class="headerlink" title="Redis 配置文件的修改"></a>Redis 配置文件的修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/redis/redis.conf <span class="comment"># 修改/etc下的redis环境配置文件</span></span><br><span class="line"></span><br><span class="line">/requirepass <span class="comment">#查找requirepass 字符，找到 “requirepass forebode 默认密码为forebode，修改为自己想要的</span></span><br><span class="line"></span><br><span class="line">/<span class="built_in">bind</span> 127.0.0.1 <span class="comment">#查找“bind 127.0.0.1”，去掉前面的 ”#“符号，即可从外部环境中访问redis，否则只能在本地访问</span></span><br></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#在配置文件修改密码之前</span></span><br><span class="line">$ redis-cli <span class="comment">#进入redis命令行环境中，默认端口为6379</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># redis命令行操作</span></span><br><span class="line"><span class="built_in">set</span> <span class="string">'a'</span> <span class="string">'b'</span> <span class="comment"># a为键，b为对应的值</span></span><br><span class="line">get <span class="string">'a'</span> <span class="comment">#获取'a'对应的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改配置文件密码之后</span></span><br><span class="line"><span class="comment">#重启redis</span></span><br><span class="line">$ sudo service redis restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入redis命令行</span></span><br><span class="line">$ redis-cli -a <span class="string">'your password'</span></span><br><span class="line"><span class="built_in">set</span> <span class="string">'a'</span> <span class="string">'b'</span></span><br><span class="line">get <span class="string">'a'</span> <span class="comment">#如果没有输入密码，则没有访问权限</span></span><br></pre></td></tr></table></figure><h2 id="Mongodb-数据库"><a href="#Mongodb-数据库" class="headerlink" title="Mongodb 数据库"></a>Mongodb 数据库</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install mongodb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动mongodb</span></span><br><span class="line">$ mongo</span><br><span class="line">&gt; <span class="comment">#进入命令行提示符</span></span><br><span class="line">&gt; show dbs <span class="comment">#显示数据库，默认有admin，local数据库</span></span><br><span class="line">&gt; use <span class="built_in">local</span> <span class="comment">#切换到local数据库</span></span><br><span class="line">&gt; db.test.insert(&#123;<span class="string">'a'</span>:<span class="string">'b'</span>&#125;) <span class="comment">#插入一条数据</span></span><br></pre></td></tr></table></figure><h2 id="MySQL-数据库"><a href="#MySQL-数据库" class="headerlink" title="MySQL 数据库"></a>MySQL 数据库</h2><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装mysql数据库的客户端，安装过程中会提示输入mysql root账户的密码，牢记</span></span><br><span class="line">$ sudo apt install myslq-client</span><br><span class="line"></span><br><span class="line"><span class="comment">#命令行下访问mysql客户端,-u 代表用户root, -p 代表密码</span></span><br><span class="line">$ myslq -u root -p</span><br><span class="line"><span class="comment"># 显示当前的数据库文档</span></span><br><span class="line">&gt; show databases;</span><br><span class="line"><span class="comment">#切换到mysql数据库</span></span><br><span class="line">&gt; use mysql</span><br><span class="line"><span class="comment"># 查看数据库下的数据</span></span><br><span class="line">&gt; select * from db</span><br><span class="line"><span class="comment"># 推出MySQL</span></span><br><span class="line">&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h3 id="修改MySQL配置文件"><a href="#修改MySQL配置文件" class="headerlink" title="修改MySQL配置文件"></a>修改MySQL配置文件</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改其中的 bind-address = 127.0.0.1,限制本地访问；注释之后即可远程访问</span></span><br></pre></td></tr></table></figure><h2 id="Python数据分析相关的库"><a href="#Python数据分析相关的库" class="headerlink" title="Python数据分析相关的库"></a>Python数据分析相关的库</h2><h3 id="升级pip"><a href="#升级pip" class="headerlink" title="升级pip"></a>升级pip</h3><p>pip3 install –upgrade pip</p><h3 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h3><pre><code>驱动浏览器的一个库，主要是用来做测试。主要针对某些使用js渲染的网站，这个时候使用requests库就无法正常获取渲染内容。用selenium就可以直接驱动浏览器，获取内容。</code></pre><p><strong>代码实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> selenium</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">driver = webdriver.Chrome() <span class="comment">#这个地方要注意，会报错，主要是由于没有安装chromedriver，官网下载chromedriver，然后配置文件路径，即可。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line"><span class="comment"># 显示网页源代码</span></span><br><span class="line">driver.page_source</span><br></pre></td></tr></table></figure><h3 id="chromedriver的安装"><a href="#chromedriver的安装" class="headerlink" title="chromedriver的安装"></a>chromedriver的安装</h3><p>下载chromedriver，按照下面的步骤进行即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget -N http://chromedriver.storage.googleapis.com/2.26/chromedriver_linux64.zip</span><br><span class="line">unzip chromedriver_linux64.zip</span><br><span class="line">chmod +x chromedriver</span><br><span class="line">sudo mv -f chromedriver /usr/<span class="built_in">local</span>/share/chromedriver</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/share/chromedriver /usr/<span class="built_in">local</span>/bin/chromedriver</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/share/chromedriver /usr/bin/chromedriver</span><br></pre></td></tr></table></figure><h3 id="安装PhantomJS"><a href="#安装PhantomJS" class="headerlink" title="安装PhantomJS"></a>安装PhantomJS</h3><p>这是一个不显示界面的浏览器。</p><p>下载phantomjs，按照chromedriver的安装一致，将chromedriver改成phantomjs即可。</p><pre><code>注意： 现在Phantomjs已经被selenium废弃了。自己观察输出。</code></pre><h3 id="lxml"><a href="#lxml" class="headerlink" title="lxml"></a>lxml</h3><p>提供xpath一个解析方式，对网页高效的一种解析方式。</p><h3 id="beautifulsoup4"><a href="#beautifulsoup4" class="headerlink" title="beautifulsoup4"></a>beautifulsoup4</h3><p>也是一个网页解析的库，依赖lxml库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ pip install beautifulsoup4</span><br><span class="line"></span><br><span class="line">&gt; from bs4 import BeautifulSoup</span><br><span class="line"><span class="comment"># 创建一个beautifulsoup对象，第一个参数是html代码，第二个参数是解析模式</span></span><br><span class="line">&gt; soup = BeautifulSoup(<span class="string">"&lt;html&gt;&lt;/html&gt;"</span>,<span class="string">"lxml"</span>)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><h3 id="pyquery"><a href="#pyquery" class="headerlink" title="pyquery"></a>pyquery</h3><p>这是一个类似与jQuery的一个库，语法与jQuery，完全一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pyquery</span><br><span class="line">$ python3</span><br><span class="line">&gt; from pyquery import PyQuery  as pq</span><br><span class="line">&gt; doc = pq(<span class="string">"&lt;html&gt;&lt;/html&gt;"</span>)</span><br><span class="line">&gt; doc = pq(<span class="string">"&lt;html&gt;Hello PyQuery&lt;/html&gt;"</span>)</span><br><span class="line">&gt; result = doc(<span class="string">"html"</span>).text()</span><br><span class="line">&gt; result</span><br></pre></td></tr></table></figure><h3 id="pymysql"><a href="#pymysql" class="headerlink" title="pymysql"></a>pymysql</h3><p>一个操作MySQL的存储库。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import pymysql</span><br><span class="line"><span class="comment"># 创建一个连接，包括主机名，用户，端口，密码，数据库等信息。</span></span><br><span class="line">conn = pymysql.connect(host = <span class="string">"localhost"</span>,user = <span class="string">"root"</span>,password = <span class="string">"wukaiyun"</span>, port = 3306, db = <span class="string">"mysql"</span>)</span><br><span class="line"></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line">cursor.execute(<span class="string">"select * from db"</span>)</span><br><span class="line"><span class="comment">#拿到MySQL中存储数据的相关内容</span></span><br><span class="line">cursor.fetchone()</span><br></pre></td></tr></table></figure></p><h3 id="pymongo"><a href="#pymongo" class="headerlink" title="pymongo"></a>pymongo</h3><p>key-value存储形式的关系型数据库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="comment"># 声明一个mongo对象</span></span><br><span class="line">client = pymongo.MongoClient(<span class="string">"localhost"</span>)</span><br><span class="line"><span class="comment"># 声明一个newtextdb的数据库</span></span><br><span class="line">db = client(<span class="string">"newtextdb"</span>)</span><br><span class="line"><span class="comment">#声明一个表名，并插入一条数据</span></span><br><span class="line">db[<span class="string">'table'</span>].insert((<span class="string">'name'</span>:<span class="string">'bob'</span>))</span><br><span class="line">db[<span class="string">'table'</span>].find_one((<span class="string">'name'</span>:<span class="string">'bob'</span>))</span><br></pre></td></tr></table></figure><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="comment"># 第一个参数为用户，第二参数为端口</span></span><br><span class="line"><span class="comment"># rd = redis.Redis("localhost",6379)</span></span><br><span class="line"><span class="comment"># 上面注释掉的是错误代码，通过help(redis.Redis()),查询到正确用法</span></span><br><span class="line">r  = redis.Redis(host =<span class="string">'localhost'</span>,port=<span class="number">6379</span>, password=<span class="string">''</span>)</span><br><span class="line"><span class="comment"># 设定一个键值对</span></span><br><span class="line">r.set(<span class="string">"name"</span>,<span class="string">'bob'</span>)</span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line">r.get(<span class="string">"name"</span>)</span><br></pre></td></tr></table></figure><h3 id="flask"><a href="#flask" class="headerlink" title="flask"></a>flask</h3><p>一个web代理的库，代理的获取，存储的一个接口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># flask的一个最小应用</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world"</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run()</span><br><span class="line"><span class="comment"># 在127.0.0.1:5000下查看效果</span></span><br></pre></td></tr></table></figure><h3 id="django"><a href="#django" class="headerlink" title="django"></a>django</h3><p>后台管理，路由，web服务器框架，一些模板引擎，可以利用其来做一个完整的网站；分布式爬虫的维护的管理系统，可能会用到。</p><h3 id="jupyter"><a href="#jupyter" class="headerlink" title="jupyter"></a>jupyter</h3><p>相当一个笔记本，支持markdown的代码记录，运行在浏览器上，可以调试运行。</p><p>依赖于很多库，其中依赖于ipython，会自动安装</p><p>使用</p><pre><code>jupyter notebook # 自动弹出浏览器，运行在8888端口上# 新建一个记事本print(&quot;hello world&quot;) #ctrl + enter运行# 按下键盘上的”b“，新增一行</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python基本环境搭建（Ubuntu16-04环境下）&quot;&gt;&lt;a href=&quot;#Python基本环境搭建（Ubuntu16-04环境下）&quot; class=&quot;headerlink&quot; title=&quot;Python基本环境搭建（Ubuntu16.04环境下）&quot;&gt;&lt;/a&gt;Py
      
    
    </summary>
    
      <category term="Python" scheme="https://binyon.github.io/categories/Python/"/>
    
      <category term="数据分析" scheme="https://binyon.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Python" scheme="https://binyon.github.io/tags/Python/"/>
    
      <category term="Redis" scheme="https://binyon.github.io/tags/Redis/"/>
    
      <category term="Mongodb" scheme="https://binyon.github.io/tags/Mongodb/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 绘制流程图</title>
    <link href="https://binyon.github.io/2018/12/30/markdown-flow/"/>
    <id>https://binyon.github.io/2018/12/30/markdown-flow/</id>
    <published>2018-12-29T16:20:44.000Z</published>
    <updated>2019-02-18T14:39:36.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流程图-amp-amp-注意事项"><a href="#流程图-amp-amp-注意事项" class="headerlink" title="流程图&amp;&amp;注意事项"></a>流程图&amp;&amp;注意事项</h2><pre><code>注意：原生的markdown不支持流程图，可以考虑使用cmdmarkdown等markdown编辑器以下的代码使用cmdmarkdown平台实现</code></pre><p><strong>代码如下</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">st=start: Start</span><br><span class="line">io=inputoutput: Verification</span><br><span class="line">op=operation: You Operation</span><br><span class="line">cond= condition: yes or no?</span><br><span class="line">sub= subroutine: your subroutine</span><br><span class="line">e= end</span><br><span class="line"></span><br><span class="line">st-io-op-cond</span><br><span class="line">cond(yes)-e</span><br><span class="line">cond(no)-sub-io</span><br></pre></td></tr></table></figure><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="/images/markdown_flow.svg" alt></p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>这样几行简单的代码就生成了一个优雅的流程图。<br>流程图大致分为两段，第一段是定义元素，第二段是定义元素之间的走向。</p><h2 id="定义元素的语法"><a href="#定义元素的语法" class="headerlink" title="定义元素的语法"></a>定义元素的语法</h2><pre><code>tag=&gt;type: content:&gt;url</code></pre><ul><li>tag就是元素名字，</li><li>type是这个元素的类型，有6中类型，分别为:</li></ul><ul><li>start         # 开始</li><li>end           # 结束</li><li>operation     # 操作</li><li>subroutine    # 子程序</li><li>condition     # 条件</li><li>inputoutput   # 输入或产出</li><li>content就是在框框中要写的内容，注意type后的冒号与文本之间一定要有个空格。</li><li>url是一个连接，与框框中的文本相绑定</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;流程图-amp-amp-注意事项&quot;&gt;&lt;a href=&quot;#流程图-amp-amp-注意事项&quot; class=&quot;headerlink&quot; title=&quot;流程图&amp;amp;&amp;amp;注意事项&quot;&gt;&lt;/a&gt;流程图&amp;amp;&amp;amp;注意事项&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;注意：原
      
    
    </summary>
    
      <category term="Markdown" scheme="https://binyon.github.io/categories/Markdown/"/>
    
    
      <category term="流程图" scheme="https://binyon.github.io/tags/%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Snipaste 好用的截图软件</title>
    <link href="https://binyon.github.io/2018/12/28/snipaste/"/>
    <id>https://binyon.github.io/2018/12/28/snipaste/</id>
    <published>2018-12-28T15:57:56.000Z</published>
    <updated>2019-02-18T14:39:36.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件Logo"><a href="#软件Logo" class="headerlink" title="软件Logo"></a>软件Logo</h2><p><img src="/images/snipaste.png" alt></p><h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><strong>Snipaste = Snip + Paste</strong></p><ul><li>Snipaste 是一个<strong>简单</strong>但强大的<strong>截图工具</strong>，也可以让你将截图贴回到屏幕上！</li><li>Snipaste 使用很简单，但同时也有一些较高级的用法可以进一步提升你的工作效率。</li><li>Snipaste 是<strong>免费软件</strong>，它也很<strong>安全</strong>，<strong>没有广告</strong>、不会扫描你的硬盘、更不会上传用户数据，它只做它应该做的事。</li></ul><h2 id="软件特色功能介绍"><a href="#软件特色功能介绍" class="headerlink" title="软件特色功能介绍"></a>软件特色功能介绍</h2><pre><code>1.要截动图的话，多了解一下可能就有了～。咱截动图不行，但是贴动图可以啊，将动图右键复制（Ctrl + C），然后按下F3，桌面动图很nice的好不好2.拖延症患者，对不起，F1截图之后F3自动贴图到桌面，同时右键分组收藏，做个备忘录也是可以的3.取色器，想要一个颜色，F1截图的时候按下c，RGB格式的颜色已经存到你的剪贴板上了，直接复制就行了。4.做教程美滋滋，截图的时候附上文字说明，任何情况下截图都OJBK5.斗图，打开你的素材库，按下F1截图，然后配上文字，一键开启斗图模式6.支持截图历史记录，截图的时候按下“，”或者是“.&quot;上下翻页，即可呈现你的截图历史，历史回放....</code></pre><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p>现目前只有<a href="https://zh.snipaste.com/download.html" target="_blank" rel="noopener"><strong>Window 版本</strong></a>和 <a href="https://zh.snipaste.com/download.html" target="_blank" rel="noopener"><strong>Mac版本</strong></a>（公测）<br>对于Window 版本的推荐使用Window 10系统，在Window 7 和 xp 上会遇到各种问题，在打开的时候会提示缺少东西。比较影响用户体验。</p><p>另外现在Window 10 已经很成熟了，可以考虑上车了。</p><p>对于<strong>个人用户</strong>，是<strong>免费</strong>的。无论专业版还是个人版，<strong>功能无差异</strong>；对于<strong>企业用户</strong>，专业版是<strong>收费的</strong>。</p><h2 id="用户手册"><a href="#用户手册" class="headerlink" title="用户手册"></a><a href="https://docs.snipaste.com/zh-cn/" target="_blank" rel="noopener">用户手册</a></h2><p>想要获取更多信息请点击用户手册，了解更多</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;软件Logo&quot;&gt;&lt;a href=&quot;#软件Logo&quot; class=&quot;headerlink&quot; title=&quot;软件Logo&quot;&gt;&lt;/a&gt;软件Logo&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/snipaste.png&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;软件介绍&quot;
      
    
    </summary>
    
      <category term="软件" scheme="https://binyon.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Snipaste" scheme="https://binyon.github.io/tags/Snipaste/"/>
    
  </entry>
  
  <entry>
    <title>LaTex入门问题汇总</title>
    <link href="https://binyon.github.io/2018/12/26/latex-basic/"/>
    <id>https://binyon.github.io/2018/12/26/latex-basic/</id>
    <published>2018-12-26T14:56:54.000Z</published>
    <updated>2019-02-18T14:39:36.739Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系统说明"><a href="#系统说明" class="headerlink" title="系统说明"></a>系统说明</h3><pre><code>平台是Ubuntu 16.04， apt install 安装的texlive。</code></pre><h3 id="给新手的建议"><a href="#给新手的建议" class="headerlink" title="给新手的建议"></a>给新手的建议</h3><ul><li>随便选一个平台，最好是找一个简单的LaTeX编辑器</li><li>不要专注与字体等美化，<strong>先熟悉基本的语法</strong>再进一步探索</li></ul><h3 id="关于LaTeX使用中文的解决办法"><a href="#关于LaTeX使用中文的解决办法" class="headerlink" title="关于LaTeX使用中文的解决办法"></a>关于LaTeX使用中文的解决办法</h3><p>直接上代码吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">\documentclass[]&#123;article&#125;</span><br><span class="line"></span><br><span class="line">\usepackage&#123;amsmath&#125; %公式支持</span><br><span class="line"></span><br><span class="line">\usepackage&#123;CJK&#125; %导入中文字体支持包</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">% 参考: http://www.linuxdiyf.com/linux/3476.html  or  http://www.latexstudio.net/archives/3561.html</span><br><span class="line">%gbsn为宋体中文字体代码，gkai为楷体中文，bkai为繁体中文</span><br><span class="line">%宋体中文测试</span><br><span class="line">\begin&#123;CJK*&#125;&#123;UTF8&#125;&#123;gbsn&#125;</span><br><span class="line">$\sum_&#123;i = 1&#125; ^n a_i = 0$,测试中文显示</span><br><span class="line">\end&#123;CJK*&#125;</span><br><span class="line"></span><br><span class="line">%顯示繁體中文的代碼</span><br><span class="line">\begin&#123;CJK*&#125;&#123;UTF8&#125;&#123;bkai&#125;</span><br><span class="line">顯示繁體中文</span><br><span class="line">\end&#123;CJK*&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure><h3 id="作者、标题、日期"><a href="#作者、标题、日期" class="headerlink" title="作者、标题、日期"></a>作者、标题、日期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">% 在begin&#123;document&#125;之前添加如下的信息</span><br><span class="line"></span><br><span class="line">\title&#123;Your title&#125; % 添加你的title名字，注意，暂时不支持中文</span><br><span class="line">\author&#123;Your author&#125; %添加你的author信息</span><br><span class="line">\date&#123;\date&#125; % \date显示今天的日期，你可以自定义输入日期，如&quot;Feb 24&quot;等</span><br><span class="line"></span><br><span class="line">% 在\begin&#123;document&#125;下首行添加,使title信息显示在文档中，否则不会有任何效果。</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"></span><br><span class="line">\maketitle</span><br><span class="line">....</span><br><span class="line">\begin&#123;document&#125;</span><br></pre></td></tr></table></figure><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><ul><li><strong>^</strong> 表示上标</li><li><strong>_</strong> 表示下标</li><li>$... $ 单个美元符号为行内公式，</li><li>\$$... $$ 两个美元符号单独为公式开一行，并居中</li><li>\begin{equation} … \end{equation}, 单独开一行并为公式编号，还有其他方法，暂不说明。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%在documentclass[]&#123;article&#125; 后添加如下代码，目的是为了导入数学公式支持包，可能不同平台有不同的包，暂时没有研究</span><br><span class="line"></span><br><span class="line">\usepackage&#123;amsmath&#125; %公式支持</span><br><span class="line"></span><br><span class="line">%数学公式,三种格式化</span><br><span class="line">% 公式的第一种表示方法，并编号</span><br><span class="line"></span><br><span class="line">\begin&#123;equation&#125;</span><br><span class="line">\sum_&#123;i = 1&#125; ^n a_i = 0</span><br><span class="line">\end&#123;equation&#125;</span><br><span class="line"></span><br><span class="line">单独开一行的公式$$\sum_&#123;i = 1&#125; ^n a_i = 0$$，</span><br><span class="line">这是一个行内公式，$\sum_&#123;i = 1&#125; ^n a_i = 0$</span><br></pre></td></tr></table></figure><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h4 id="加粗、斜体、下划线、强调"><a href="#加粗、斜体、下划线、强调" class="headerlink" title="加粗、斜体、下划线、强调"></a>加粗、斜体、下划线、强调</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">\textbf&#123;Bold&#125; ,%加粗Bold单词</span><br><span class="line">\textit&#123;Italic&#125; ,%将Italic变成斜体</span><br><span class="line">\underline&#123;underline&#125;, %给underline添加下划线</span><br><span class="line"></span><br><span class="line">\textbf&#123;\textit&#123;bold and italic&#125;&#125;, %加粗并变成斜体</span><br><span class="line"></span><br><span class="line">%强调 \emph,将会用斜体展示</span><br><span class="line">\emph&#123;this is a long sentence&#125;</span><br></pre></td></tr></table></figure><h3 id="章节和段落、目录"><a href="#章节和段落、目录" class="headerlink" title="章节和段落、目录"></a>章节和段落、目录</h3><ul><li>\section 章节</li><li>\subsection{} 子章节，注意subsection和{}之间不要有空格，不然会创建子标题失败，原因不明，应该是语法规定，可以通过语法高亮提示修正</li><li>\paragraph 段落</li><li>\tableofcontents 目录</li><li>以上都是单独的,默认编号格式为罗马数字;默认没有缩进</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">%为章节添加一个目录</span><br><span class="line">\tableofcontents </span><br><span class="line"></span><br><span class="line">%创建一个章节</span><br><span class="line">\section&#123; Hello section&#125;</span><br><span class="line">This is a section.</span><br><span class="line">\subsection&#123; Hello subsection1&#125;</span><br><span class="line">This is a subsection.</span><br><span class="line">\paragraph &#123; Hello paragraph&#125;</span><br><span class="line">This is a paragraph.</span><br><span class="line">\subparagraph &#123; Hello subparagraph&#125;</span><br><span class="line">This is a subparagraph.</span><br><span class="line"></span><br><span class="line">\subsection &#123; Hello subsection2&#125;</span><br><span class="line">\paragraph&#123;this is a paragraph&#125;</span><br></pre></td></tr></table></figure><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><ul><li>换行使用 “\“</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我在第一行 \\ 我在第二行\\我在第三行</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;系统说明&quot;&gt;&lt;a href=&quot;#系统说明&quot; class=&quot;headerlink&quot; title=&quot;系统说明&quot;&gt;&lt;/a&gt;系统说明&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;平台是Ubuntu 16.04， apt install 安装的texlive。
&lt;/code&gt;&lt;/pre&gt;
      
    
    </summary>
    
      <category term="LaTeX" scheme="https://binyon.github.io/categories/LaTeX/"/>
    
    
      <category term="LaTeX" scheme="https://binyon.github.io/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>相机基本组成（尼康d5600）</title>
    <link href="https://binyon.github.io/2018/12/25/Single-lens-reflex-camera/"/>
    <id>https://binyon.github.io/2018/12/25/Single-lens-reflex-camera/</id>
    <published>2018-12-25T14:17:35.000Z</published>
    <updated>2019-02-18T14:39:36.735Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-图像传感器（CMOS）"><a href="#1-图像传感器（CMOS）" class="headerlink" title="1. 图像传感器（CMOS）"></a>1. 图像传感器（CMOS）</h3><blockquote><p>在胶片时代，<strong>胶片</strong>就是图像传感器</p></blockquote><blockquote><p>在数码时代，<strong>CMOS</strong>就是图像传感器,即感光元件。</p></blockquote><h3 id="2-感光度（ISO）"><a href="#2-感光度（ISO）" class="headerlink" title="2. 感光度（ISO）"></a>2. 感光度（ISO）</h3><blockquote><p>感光度，顾名思义，即感受光线的程度</p><p>这是从胶片时代继承过来的产物，在 <strong>胶片时代</strong> 感光度就是底片对光线的反应速度，即底片盒上的数字大小，对应的数字越大，对光线的敏感性越高，达到相同的亮度，所需要的 <strong>曝光时间</strong>（底片接受光线照射的时间） 也就越短。</p><p>但是有个问题，就是<strong>感光度越高</strong>，相应的拍摄出来的<strong>画质越差</strong>， <strong>噪点越多、细节丢失、颜色偏移</strong>。所以通常选用低感光度（XXXX-XXXX）</p></blockquote><h3 id="3-快门速度"><a href="#3-快门速度" class="headerlink" title="3. 快门速度"></a>3. 快门速度</h3><blockquote><p>快门，或快门单元，简单说就是一块挡在 <strong>CMOS</strong>前面的一块板子，在快门没有按下的时候，光线照不进来，按下快门的时候，打开，让光线照在 <strong>CMOS</strong> 上面,从而得到了曝光，光线转变为电信号存储在记忆卡中。</p><p>快门速度，即 <strong>快门开启的时间</strong>, 快门开启的时间越长，进入的光线越多，曝光就会增加, 快门速度也是摄影内容的一个核心n内容—— <strong>曝光</strong>。</p><p>同时由于快门开启，底片上记录的事物会发生重叠，总的来说就是，快门时间越长，里面的东西就会越模糊，<strong>汽车光带就是这样拍摄的，通过长时间曝光</strong></p><p><strong>总结：</strong>，<strong>高速快门</strong>可以记录瞬间的事物，如飞溅的水滴，奔跑的宠物，运动题材的。 <strong>低速快门</strong>可以记录时间的流逝。</p></blockquote><h3 id="4-光圈"><a href="#4-光圈" class="headerlink" title="4. 光圈"></a>4. 光圈</h3><blockquote><p><strong>光圈</strong>这个参数是和镜头连接在一起的。所以我们先介绍一下镜头。</p></blockquote><h4 id="4-1-镜头"><a href="#4-1-镜头" class="headerlink" title="4.1 镜头"></a>4.1 镜头</h4><p>镜头分为 <strong>定焦镜头</strong> 和 <strong>变焦镜头</strong>。</p><blockquote><p><strong>区别：</strong> 定焦镜头的 <strong>视角</strong> 是固定的， <strong>变焦镜头</strong>的视角是可以在一定范围内变动的。<br><strong>焦距：</strong> 分为<strong>广角镜头</strong>，<strong>标准镜头</strong>和<strong>长焦镜头</strong>。通俗来讲即 <strong>照大视角的</strong>， <strong>照人像的</strong> 和 <strong>照远距离的</strong></p></blockquote><h4 id="4-2-光圈"><a href="#4-2-光圈" class="headerlink" title="4.2 光圈"></a>4.2 光圈</h4><p>光圈就像是人的瞳孔，和<strong>快门速度</strong>共同决定了 <strong>进光量(即进入的光线多少）</strong>。</p><p>光圈越小，单位时间进入的光线量就越少；光圈越大，单位时间内进入的光线越多。</p><blockquote><p>注意： <strong>光圈的大小和相机镜头的F值互为倒数，F值越大，光圈越小，F值越小，光圈越大</strong></p></blockquote><p>除此之外，还会影响要拍摄的照片的效果，这里涉及到一个概念，<strong>景深</strong>。</p><h4 id="4-3-景深"><a href="#4-3-景深" class="headerlink" title="4.3 景深"></a>4.3 景深</h4><p>景深即背景的清晰度，相机得到清晰景物的深度。背景的清晰度越高，景深越大；背景的清晰度越低（<strong>虚化</strong>），景深越浅。很好理解，类比人眼，背景越清晰，即看得越远（深入）。</p><blockquote><p>如何使用</p><ol><li>拍摄人像的时候，为了突出人物（特写），选用大光圈，低景深，模糊背景，以此来凸显人物。<strong>（虚化）</strong></li><li>拍摄花卉，表现花卉植物的某些特点。<strong>（虚化）</strong></li></ol></blockquote><p><strong>总结：</strong></p><ul><li>光圈大，虽然会有 <strong>虚化</strong> 的效果，但是有的时候在光线很充足的时候会导致<strong>过度曝光</strong>，画面失真。</li><li>光圈小，虽然能够捕获到足够<strong>清晰、锐利</strong>的照片，但如果光圈过小，由于物理光学原理，会发生 <strong>衍射</strong>,导致画面不锐利。</li></ul><h3 id="5-虚化"><a href="#5-虚化" class="headerlink" title="5. 虚化"></a>5. <strong>虚化</strong></h3><p>虚化三大件，焦距，拍摄距离，光圈。</p><ul><li>焦距越长，越容易产生虚化。</li><li>拍摄距离越近，越容易产生虚化</li><li>光圈越大，越容易产生虚化</li></ul><h3 id="6-全幅-or-残幅-APS-C"><a href="#6-全幅-or-残幅-APS-C" class="headerlink" title="6. 全幅 or 残幅(APS-C)"></a>6. 全幅 or 残幅(APS-C)</h3><blockquote><p>由于历史原因，在数码单反相机面世的时候，CMOS的价格非常高（36 <em> 24mm），导致相机价格很贵，这个时候聪明的工程师们想出了一个很好的解决拌饭，即减小CMOS的面积（24 </em> 13mm），以降低单反的价格，以此来更好的推广单反相机。<br>但是这又出现了一个问题，即标题所讲的 <strong>全幅OR残幅</strong> 之争，也是每一个新手在选择相机的时候面临的一个大问题。</p><p>未完待续</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-图像传感器（CMOS）&quot;&gt;&lt;a href=&quot;#1-图像传感器（CMOS）&quot; class=&quot;headerlink&quot; title=&quot;1. 图像传感器（CMOS）&quot;&gt;&lt;/a&gt;1. 图像传感器（CMOS）&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在胶片时代，&lt;stro
      
    
    </summary>
    
      <category term="摄影" scheme="https://binyon.github.io/categories/%E6%91%84%E5%BD%B1/"/>
    
    
      <category term="感光度" scheme="https://binyon.github.io/tags/%E6%84%9F%E5%85%89%E5%BA%A6/"/>
    
      <category term="分类" scheme="https://binyon.github.io/tags/%E5%88%86%E7%B1%BB/"/>
    
  </entry>
  
</feed>
