<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Windows 10 中Ubuntu子系统 文件互访]]></title>
    <url>%2F2019%2F02%2F18%2Fwindow10-sublinux%2F</url>
    <content type="text"><![CDATA[简单的说，Windows的系统盘被挂载到了/mnt目录下, 我们用命令 wsl 系统安装的linux子系统, 使用 cd /mnt 切换到对应的目录, 使用ls命令列出当前的目录下的文件夹,可以看到就是我们的两个系统盘的盘符,我有两个盘,一个C盘和一个D盘. //todo 我们成功切换到了系统盘之后, 可以直接在bash中使用各种linux下的命令,如mv, cp, 等一系列命令. 也可以切换到对应的目录编辑文档. 比如说我这个博客就是在Ubuntu下建立的,现在切换到Windows平台下, 使用wsl就可以完成以前在Ubuntu上的操作.没有任何差别. 如果有差别的话,就是编译速度有点慢,git下载速度慢,系统资源占用比较多]]></content>
  </entry>
  <entry>
    <title><![CDATA[一篇记录git使用的方法]]></title>
    <url>%2F2019%2F01%2F24%2Fgit-use%2F</url>
    <content type="text"><![CDATA[Git 是什么?Git 获取安装//Todo Ubuntusudo apt-get install git Windows 7 orhigher推荐使用 gitforWindows 提供的git工具,百度搜索第一个就是. Git 使用前配置启动Ubuntu 下不需要多余的配置,安装之后打开terminal即可 Windows下默认安装不需要配置, 直接运行git bash即可. Git 初始化先创建一个文件夹, 通过命令行的形式 cd your_dir 进入输入命令 git init init表示初始化,表示创建一个空的Git 仓库, 或者是重新初始化一个已经存在的 Git 仓库 123456# 创建一个git学习文件夹然后进入$ mkdir git_learn$ cd git_learn# 初始化git_learn为一个git仓库$ git init Git 使用前配置学习资料12345git clone https://github.com/iissnan/progit.git progitcd progitnpm install 初始化分支1234567$ git init #运行此命令之后会在当前的目录中出现一个.git文件夹$ git add *.c *.py # 把当前目录中的.c,.py文件纳入版本管理系统中。即将其放入暂存区域，把未进行追踪的文件进行追踪$ git add README$ git commit -m "initial project version" 从现有仓库克隆123456# 克隆远程的hexo仓库，并在本地命名为myhexo$ git clone git://github.com/binyon/hexo.git myhexo$ git status #查看当前的状态，有多少个分支，目录，记录$ git add *.c # 如果多次修改的话，则需要将其多提add操作，否则它将只会记录你之前提交的那个时间点上的修改。 gitignore 文件1234# 将不需要追踪的文件放入里面，如 .[oa], .[c]等文件， *~忽略以波浪号结尾的文件。# 说明# 以#开头的或者是空行的都会被忽略, 匹配模式下的跟反斜杠表示要忽略的是目录, 要忽略指定匹配模式以外的文件,在前面加上反引号(!) 举例说明如下 # 这个是注释,将被.git忽略 # 忽略所有以.a结尾的文件 *.a # 但是lib.a除外 !lib.a # 仅仅忽略Todo下的所有文件,但不包括subdir/Todo /Todo # 忽略build目录下的所有文件, build/ # 会忽略doc/notes.txt,但是不包括doc/server/server.txt doc/*.txt # 忽略所有的在doc目录下的txt文件 doc/**/*.txt git status and git diffgit status仅仅只能列出修改过的文件,但是针对具体的修改了那一部分的话需要使用git diff命令 12345678910# 查看当前文件与暂存区中的对照$ git diff# 查看暂存起来的和上次提交之间的差异,也可以使用git diff --staged$ git diff --cached# 提交运行,运行此命令将会调用默认的编辑器来编辑提交记录$ git commit$ git commit -a #会将所有已经在追踪过的文件提交,跳过git add环节 移除文件移除文件,就是要将其不要被git追踪,移除之后将会出现在未追踪清单中”changes not staged for commit”部分. 12345678910111213$ rm .git# 查看状态$ git status # 在状态中将会显示deleted : .git# 记录这次移除$ git rm "filename"### 注意:如果之前在删除之前放入暂存区,则需要使用强制命令,-f删除# 另一种情况# 把文件从git中删除追踪,但是保留之前提交的文件.$ git rm --cached readme.txt$ git rm log/\*.log 移动文件说明:git并不追踪文件移动操作. 123456$ git mv file_from file_to#说明上面命令相当于运行了以下的三个命令$ mv file_from file_to$ git rm file_from$ git add file_to 远程仓库的使用在克隆完一个git项目之后至少会有一个origin的远程库 12$ git remote # origin$ git remote -v # -verbose 查看对应的地址 添加远程仓库1234$ git remote add [shortname] [url] # 用shortname来指代url对应的仓库$ git fetch [shortname] 从远程仓库获取数据123456$ git fetch [remote-name]### 注意,下面命令会取得你从上次克隆之后的所有更新文件,但是不会自动合并.$ git fetch origin $ git pull #会自动合并, 推送到远程仓库12# 默认使用origin 和 master$ git push [remote-name] [branch-name] 删除远程分支语法, git push [远程名] [本地分支]:[远程分支] 如果你想要在服务器上删除远程分支backup,1$ git push origin :backup 创建git分支123456789101112131415$ git checkout -b backup# 以上命令等同于$ git branch backup$ git checkout backup$ git checkout master$ git merge backup # 合并两个分支$ git branch -d backup # 合并之后不需要就删除这个分支# 合并时遇到冲突$ git status #查看问题出现在哪$ git add #解决问题之后将其标记为已解决$ git mergetool # or opendiff，调用默认工具合并]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Conda 基本使用方法]]></title>
    <url>%2F2019%2F01%2F23%2Fconda-use%2F</url>
    <content type="text"><![CDATA[conda简介conda使用 命令行模式使用 123456789101112131415161718192021222324# 查看当前的conda环境conda info -e# 查看conda帮助conda -h# 查看conda下的create帮助conda create -h# 列出当前的conda环境conda env list #创建一个3.6版本的conda环境conda create --name Python36 python=3.6# 激活上面创建的conda环境conda activate Python36# 退出上面的环境conda deactivate#删除上面创建的conda环境conda remove --name Python36 --all anaconda-navigator交互模式使用 支持选项比较少，只有create，import和remove三个选项。创建和删除的时候只需要输入环境的名字即可。 conda环境安装位置默认在anaconda安装路径下的envs目录下，各个平台都相同。]]></content>
      <categories>
        <category>Conda</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Conda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-studio 踩坑纪实]]></title>
    <url>%2F2019%2F01%2F23%2Fandroid-studio%2F</url>
    <content type="text"><![CDATA[版本号android studio v3.2.1 Android studio 初次安装坑下载问题在国内，安装Android studio可以说是相当麻烦的，除了要费尽心力去下载Android studio的安装包，还要面对安装Android studio过程中下载Android sdk的麻烦。 由于是校园网，支持ipv6，不知道外面能否直接访问Android官网下载Android studio，就不考虑这一步吧。 虽然有ipv6加持，但是在安装Android studio过程中还是会遇到下载Android sdk的问题，依然是无法访问Google。 解决方法 方法一 github上下载xx-net,按照官方文档安装 Android studio 提示无法下载的时候，设置proxy代理，代理到xx-net上。host：127.0.0.1，port：8086 下载安装，会比较慢。注意:这个方法问题比较多,可以尝试方法2. 但是这不失为一种科学上网的方法. 方法二 选择国内镜像, 可以参考如下链接的回答, 国内镜像使用, 主面板右下角的Configure –&gt; settings –&gt; Appearance &amp; Behavior –&gt; System Settings –&gt; HTTP Proxy，选中Auto-detect proxy settings，勾选下方Automatic proxy configuration URL，填入国内的某个镜像站。这里，我选择的是mirrors.neusoft.edu.cn:80。 Android studio 初次编译坑安装好Android sdk之后还有一个问题，新建helloworld工程之后，要使用gradle编译。 解决办法如果是使用上面的方法一下载Android sdk，那么遇到gradle编译失败时，需要考虑将代理修改回原本的设置。gradle在配置的时候会默认使用原来的网络代理，且一直使用，这个需要手动修改。 因为gradle官网是可以访问的，不需要设置代理，代理之后会出现各种问题。以下为修改方案 找到工程下的Gradle的gradle.properties，注释掉： // 这是我用xx-net代理的配置 systemProp.https.proxyPort=8086 systemProp.http.proxyHost=127.0.0.1 systemProp.https.proxyHost=127.0.0.1 systemProp.http.proxyPort=8086 或者是有http代理，但是没有https代理，对应添加https代理 Android studio运行坑完成编译之后, 对于初学者来说最重要的是看到我完成了什么, 通过运行可以进一步增加我们的成就感. 那么在运行项目的时候, 有那些需要注意的呢? 12电脑内存过小的话, 8 g 起步吧. 就不推荐虚拟机运行,需要下载镜像,这是比较麻烦的,而且运行速度慢,还需要编译推荐使用电脑usb连接手机, 开启usb调试模式, 直接就在手机上编译运行了,对于编译速度来说相当有保证.]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android studio</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 再次入门记录]]></title>
    <url>%2F2019%2F01%2F23%2Fpython-new%2F</url>
    <content type="text"><![CDATA[Python的解释器Python有多种解释器。 Cpython其中默认的是cpython，是用c语言写的Python解释器。有历史背景，开发Python这门编程语言的时候，c语言占据了编程世界的主要地位，且运行速度快，更接近硬件底层。所以。 提示符为： &gt;&gt;&gt; Ipythonipython，全称可以理解为interaction python，可以实时展示Python的运行效果。 提示符为： ln[序号]： == 推荐使用jupyter notebook 记录编码过程和做笔记 == PyPyPyPy 是另一个 Python 解释器，它的目标是执行速度。 PyPy 采用 JIT 技术，对 Python 代码进行动态编译（注意不是解释），所以可以显著提高 Python 代码的执行速度。 JythonJython 是运行在 Java 平台上的 Python 解释器，可以直接把 Python 代码编译成 Java 字节码执行。 IronPythonIronPython 和 Jython 类似，只不过 IronPython 是运行在微软.Net 平台上的 Python 解释器，可以直接把 Python 代码编译成.Net 的字节码。 小结Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。 Python 编辑器编辑器之争对于Python的编辑器有太多选择了, 有各种IDE,还有各种文本编辑器. 但是对于初学者, 我们需要的是对于Python的基本语法快速熟悉. 不要在细枝末节上做纠结, 导致舍本逐末. 这里我推荐使用 thonny 这个专门为Python初学者开发的编辑器, 足够简单, 功能也足够强大. Thonny 具备自动补全 具备一定的debug功能 可靠的包管理器,集成pip 集成最新的python3 有错误建议 等到该编辑器不够使用之后再进一步学习 ide 的使用吧. (可以使用pycharm) 基本语法输入和输出1234567# 输出 dog cat pig, 用逗号分割print('dog ' , 'cat ', 'pig')# 输入youIn = input("please input some chacter: ")# 两种格式化输出方式print("you input is %s", youIn)print("you input is :%s" % (youIn)) 格式化输出 TODO缩进\注释缩进一般使用 Tab , 四个空格. 有助于写出格式化的代码,但是当复制代码的时候就很麻烦. 使用ide很难格式化Python的代码. 空格和Tab一定不能混用 , 混用之后很麻烦.初学者一般是在这里出错. 注释 使用 #, 单行注释. 使用三个单引号或双引号, 多行注释 1234567891011121314151617181920212223# 这是一条单行注释'''这是几条多行注释,一般用于文件开头,说明作者, 代码意图, 写代码时间等.'''"""这也是多行注释这也是多上注释"""# 上面的两条代码也可以用于多行输出,试试如下代码print("""这也是多行注释这也是多上注释""")print('''这是几条多行注释,一般用于文件开头,说明作者, 代码意图, 写代码时间等.''') Python 面向对象编程面向对象的概念面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向对象程序设计将程序拆分成一系列的命令集合, 为了简化复杂度, 将一个复杂的函数拆分成各种简单的函数. 即 大函数 -&gt; 小函数 面向对象程序设计将程序拆分成多个对象的组合, 一个对象可以处理另一个对象传递过来的数据. Python中所有的数据类型都是对象. 面向对象思想面向对象的设计思想是抽象出Class，根据Class创建Instance 面向对象的抽象程度比函数要高, 既包含数据, 也包含处理数据的方法. 类起一个模板的作用, 必须包含基本的属性. 实例创建一个类的基本方法12345678910111213class #表示声明一个类,后面紧跟类名. 类名通产是大写开头.object # 表示该类是从那个类继承下来的, 是所有的类都会继承的. 没有明确继承就写object.# 基本构造class Student(object): pass# 通过__init__ 方法, 绑定属性, 起到模板作用.class Student(object): # self 表示创建的实例本身 def __init__(self, name, score): self.name = name self.score = score 处理学生成绩 函数方式处理对应的数据 1234567# 需要处理的数据std1 = &#123;'name':'Tom', 'score':81&#125;std2 = &#123;'name':'Mac', 'score':90&#125;# 打印学生成绩def print_score(std): print('%s : %s' % (std['name'], std['score'])) 面向对象思想处理学生成绩实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Student(object): # 数据 def __init__(self, name, score): self.name = name self.score = score # 函数 -&gt; 类的方法, 调用student类自身的函数, 打印成绩 def print_score(self): print("%s : %s" % (self.name, self.score) ) # 创建一个新方法 def get_grade(self): if self.score &gt;= 90: return 'A' elif self.score &gt;= 60: return 'B' else: return 'C'# 面向对象代码, 传入与 __init__ 方法有相同属性的实例.bart = Student('Bart Simpson', 59)lisa = Student('Lisa Simpson', 87)bart.print_score()lisa.print_score()# 直接在外部修改student实例的score属性值&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; lisa = Student('Lisa Simpson', 87)&gt;&gt;&gt; bart.score = 5050&gt;&gt;&gt; bart.score = 70# 限制外部代码修改实例的name, score 属性# 通过双下划线(`__`)将其属性变成私有变量, 以达到拒绝外部访问的效果# 对于单下划线的变量虽然可以直接访问,但是我们将其视作私有变量, 不要随意访问# __variable__ 这种变量是特殊变量, 可以直接访问def __init__(self, name , score): self.__name = name self.__score = scoredef print_score(self): print('%s :%s' % (self.__name), self.__score)# 获取对应的属性值def get_name(self): return self.__namedef get_score(self): return self.__score# 修改内部的属性值def set_name(self, name): self.__name = namedef set_score(self, score): self.__score = score# 双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量&gt;&gt;&gt; bart._Student__name"bart"# 注意以下的一种错误写法&gt;&gt;&gt; bart.__name = 'bart 2'&gt;&gt;&gt; bart.__name'bart 2'# 看似成功修改了__name的属性值, 可是调用如下方法却会发现没有修改&gt;&gt;&gt; bart.get_name()'bart' 对象(Class)和实例(Instance) 对象Class 即一类事物的合集, 是一种抽象概念. 具有同一特性的一类事物的总称. 如所有的 Student(Class) 实例Instance 即一类事物中的一个具体存在的个体, 是实际存在的一个. 如一个叫 Tom(Instance) 的 Student(Class) 方法和函数的区别方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据 继承和多态 继承 12345678910111213141516171819202122232425# 假设我们定义了一个Animal类# 父类, 被继承的类class Animal(object): # animal run method def run(self): print('animal\'s run...')# 子类,继承自Animal, 所有的对象都继承自object, 自动拥有了父类的所有方法class Dog(Animal): pass# 测试代码xiaohaung = Dog()# 这里我们虽然在dog类中什么都没做, 但是依然具有run方法, 这就是继承xiaohuang.run()# 类型检查, 子类可以看做是父类, 但是父类不能看做是子类. # 比如 黄种人是人, 但是人不一定是黄种人.isinstance(xiaohuang, Animal) # Trueisinstance(xiaohuang , Dog) # True# 但是animal = Animal()isinstance(animal, Dog) # false 多重继承 对于不同事物，我们有不同的分类，各种分类方式之间可能完全不交叉，也可能有所交叉当我们进行程序设计的时候，如果要给每一个类都进行划分，对于不同的类又有不同的功能。我们很难穷举出所有的分类来。在此我们采用多重继承的方式来解决这个问题 12 多态 1234567891011121314151617181920# 我们重写子类中的run方法class Dog(Animal): def run(self): print("dog is run...")xiaohaung = Dog()xiaohaung.run()# 输出结果表示子类的run方法得到了运行, 父类的没有被运行.# 因为代码在运行的时候总是会优先使用子类有了的方法.# 以上是多态的一种# 多态的好处def print_run(Animal): Animal.run() Animal.run()# 测试print)run(xiaohuang)animal = Animal()print_run(animal) 以上例子说明我们不用修改代码, 通过传入不同的类就能获得不同的输出结果. 获取对象信息我们拿到一个对象的时候, 如何知道这个对象是什么类型, 有什么方法 type()对于基本类型, 使用type()函数判断对象类型 123456789101112&gt;&gt;&gt; type(123), type('str')&lt;class 'int'&gt;, &lt;class 'str'&gt;&gt;&gt;&gt; type(int), type(str)&lt;class 'type'&gt;, &lt;classs 'type'&gt;&gt;&gt;&gt; type(None)&lt;class 'NoneType'&gt;# 对于内置的函数&gt;&gt;&gt; type(abs)&lt;class 'builtin_function_or_method'&gt; 判断一个对象是否是函数, 可以用一个types库中的函数123456789101112&gt;&gt;&gt; import types&gt;&gt;&gt; def fn(): pass# 自定义函数类型&gt;&gt;&gt; type(fn) == types.FunctionTypeTrue# 内置函数类型&gt;&gt;&gt; type(abs) == types.BuiltinFunctionTypeTrue# 生成器类型&gt;&gt;&gt; type(x for x in range(10)) == types.GeneratorType 对于类的继承关系来讲, 使用isinstance()object -&gt; Person -&gt; YellowPerson -&gt; SichuanPerson 使用isinstance() 可以判断继承关系, 也可以替代type()函数, 所以我们总是优先使用isinstance(). 1234567891011121314151617181920212223242526272829303132333435# 判断基本类型&gt;&gt;&gt; isinstance('123', str)True&gt;&gt;&gt; isinstance(123, int)True# 判断变量是否是多个类别中的一种&gt;&gt;&gt; isinstance([12,3], (tuple, list))True&gt;&gt;&gt; isinstance(&#123;'name':bin, 'age':12&#125;, (dict, list))True# 判断继承关系&gt;&gt;&gt; class Person(object): def say(self): print("I'm a person")class YellowPerson(Person): def say(self): print("I'm a yellowperson")class SichuanPerson(YellowPerson): def say(self): print("I'm a sichuanperson") &gt;&gt;&gt; person = Person()&gt;&gt;&gt; yellowPerson = YellowPerson()&gt;&gt;&gt; sichuan = SichuanPerson()&gt;&gt;&gt; person.say()I'm a person&gt;&gt;&gt; yellowPerson.say&lt;bound method YellowPerson.say of &lt;__main__.YellowPerson object at 0x7f3f4d2de630&gt;&gt;&gt;&gt;&gt; yellowPerson.say()I'm a yellowperson&gt;&gt;&gt; sichuan.say()I'm a sichuanperson 使用dir()dir() 用于获得对象的所有方法和属性. 尤其是当不知道对象具有什么属性的时候123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt; dir(person) # 一长串, 自定义的方法出现在最后# 配合hasattr(), getattr(), setattr() 函数, 可以很方便的为对象添加属性和方法# 一个完整演示 dir(), hasattr(), getattr(), setattr()的例子&gt;&gt;&gt; class MyPower(int): def __init__(self, x): self.x = x def power(self): return self.x * self.x &gt;&gt;&gt; obj = MyPower(2)&gt;&gt;&gt; obj.power()4&gt;&gt;&gt; hasattr(obj, 'x') # obj 有x属性吗True&gt;&gt;&gt; getattr(obj, 'x') # obj2&gt;&gt;&gt; getattr(obj, 'x') # 获取obj.x对应的属性值, 如果没有这个属性则会报错2&gt;&gt;&gt; setattr(obj, 'y')Traceback (most recent call last): File "&lt;pyshell&gt;", line 1, in &lt;module&gt;TypeError: setattr expected 3 arguments, got 2&gt;&gt;&gt; setattr(obj, 'y', 12)&gt;&gt;&gt; setattr(obj, 'y', 12) # 设置obj的属性值&gt;&gt;&gt; hasattr(obj, 'y')True&gt;&gt;&gt; getattr(obj, 'y')12&gt;&gt;&gt; dir(obj) #列出obj的所有属性和方法['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dict__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__module__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'power', 'real', 'to_bytes', 'x', 'y']&gt;&gt;&gt; dir(obj) #列出obj的所有属性和方法 Python 面向对象高级给实例增加属性和方法123456789101112131415161718192021222324# 正常情况下我们创建了一个class类，由于动态语言的灵活性#我们可以给其实例添加任何属性和方法。具体如下class Student(object): pass# 测试# 给实例添加属性s1 = Student()s1.name = 'bing's1.age = 12# 打印输出对应的名字和年纪print(s1.name, s1.age)# 给实例添加方法# 先定义一个方法def set_score(self, score): self.score = scorefrom types import MethodType# 绑定方法s1.set_score = MethodType(set_score, s1)s1.set_score(90)print(s1.score) 注意：以上方法绑定的属性和方法，只适用于当前生成的实例，不适用于新创建的实例。 给对象增加属性和方法1234567891011# 定义一个函数def set_gender(self, gender): self.gender = gender# 给类绑定属性和方法Student.set_gender = set_gender# 测试s2 = Student()s2.gender = 'male'print(s2.gender)# =&gt; 输出为 male 限制实例的属性有的时候我们不想要让一个实例,随便添加任何的属性的.这个时候我们可以用slot方法来限制创建的实例的属性. 123456789101112131415# 限制实例的属性class Student_slots(object): __slots__ = ('name', 'age', 'gender') # 使用tuple方式限制实例的属性名称# 测试# 创建新实例s3 = Student_slot()s3.name = 'bing's3.age = 12s3.gender = 'male'# 多出来的属性,会抛出异常 AttributeErrors3.score = 90# print(s3.score) 注意: slots定义的属性仅对当前类实例起作用，对继承的子类是不起作用的 对于属性的保护两种方法.123456789101112131415161718192021222324252627282930313233343536373839# 第一种方法,通过get_attr, set_attr的方式来限制对于属性的访问class Student_limit(object): def set_score(self, score): if not isinstance(score, int): raise ValueError("score is not a integer") if score &lt; 0 or score &gt; 100: raise ValueError("the score is out of range") self.__score = score def get_score(self): return self.__scores4 = Student_limit()s4.set_score(100)print(s4.get_score())# 第二种方法, Python内置的装饰器# 相对与第一种方法,更加简便# Python内置的@property装饰器就是负责把一个方法变成属性调用的# 把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值class Student_limit2(object): @property def score(self): return self.__score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError("the value is not a integer") if value &lt; 0 or value &gt; 100: raise ValueError("the value is out of range") self.__score = values5 = Student_limit2()s5.score = 60 # 实际转化为s5.set_score(60)print(s5.score) # 实际转化为s5.get_score()# 通过该方法还可以制定只读属性, 只定义getter方法,不定义setter方法 一个完整的类我们以学生类为例 1234567891011# 学生类继承自object类，所有的类都继承自object，学生类也可以继承自Person类，Primary类, 如class Student(Primary):# 如果使用多个类继承则为多重继承，具有多个类的功能，如class Student(Person, Primary)class Student(object): # 初始化实例 def __init__(self, name, id, gender): self.__name = name self.__id = id self.__gender = gender def __str__(self): return "Student's object's name &#123;&#125;".format(self.__name)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学史概论]]></title>
    <url>%2F2019%2F01%2F16%2Fmath-history%2F</url>
    <content type="text"><![CDATA[数学史——人类文明史的重要篇章了解历史的变化是了解这门科学的一个步骤——陈省身 数学史的意义数学史对于深刻理解作为科学本身的数学，还是全面了解整个人类文明的发展都具有重要意义。 不了解数学史，就不可能全面了解整个人类文明史。 莱布尼茨说，“知道重大发明特别是那些绝非偶然的、经过深思熟虑而得到的重大发明的真正起源是很有益的。这不仅仅在于历史可以给每一个发明者应该有的评价，从而鼓舞其他人去争取同样的荣誉，而且还在于通过一些光辉的返利可以促进发现的艺术，解释发现的方法。” 庞加莱说，“如果我们希望预知数学的将来，适当的途径是研究这门学科的历史和现状。” 庞加莱[1854-1912]，被称作是最后一位数学通才。 希尔伯特[1862-1943]，“数学科学是一个不可分割的整体，它的生命力正式在于各个部分之间的联系“。 数学是-一门历史性或积累性很强的科学，如数的理论的演进；非欧几何对于欧式几何的拓宽等。 数学在人类文明史上有特殊的地位，是由数学作为一种文化的特点决定的。 首先，数学是以抽象的，追求高度精确、可靠的知识。 其次，对于一般性模式的追求，使数学具有广泛的适用性。三角形的面积公式，微积分的创立作为解一般性的无限小算法的结果。 同一组偏微分方程可以用于解流体动态，在弹性力学中用来描写振动过程，在声学中用来描述声音的传播等。 最后，数学作为一种创造性活动，还具有艺术特征，这就是对美的追求。英国数学家和哲学家罗素说，“数学不仅拥有真理，而且还有至高无上的美——一种冷峻严肃的美，就像是一尊雕像。这种美没有绘画或音乐那样华丽的装饰，它可以纯洁到崇高的程度，能够达到严格的只有最伟大的艺术才能显示的完美境界。” 什么是数学数学本身是一个历史概念，数学的内涵随着时代的变化而变化，给数学下一个一劳永逸的定义是不可能的。 数学是量的科学。数学是研究现实世界的空间形式与数量关系的科学。现代数学就是各种量之间的可能的，一般说是各种变化着的量的关系和相互联系的数学。 关于数学历史的分期]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-urllib库学习]]></title>
    <url>%2F2019%2F01%2F04%2Fpython-urllib%2F</url>
    <content type="text"><![CDATA[什么是urllib库 Python内置的一个库 urllib.request 请求模块 urllib.error 异常模块 urllib.parse url解析库 urllib.robotparser robot.text解析的库 Python3相对于Python2的变化python2123import urllib2response = urllib.urlopen("http://www.baidu.com") python3 12import urllib.requestresponse = urllib.request.urlopen("http://www.baidu.com") 注意：requests 以urllib为基础实现的 urllib.request1234567891011121314151617181920212223import urllib.request# 输出 urllib.request 的帮助文档，help(urllib.request)，如下urlopen(url, data=None, timeout=&lt;object object at 0x7f66eab220c0&gt;, *, cafile=None, capath=None, cadefault=False, context=None)url = "http://httpbin.org"response = urllib.request.urlopen(url = url + str('get'),timeout = 2)print(response.read())try: response = urllib.request.urlopen(url = url+str('get'),timeout = 0.1)except urllib.error.URLError as e: if isinstance(e.reason, socket.timeout): print("timeout error")# 构造一个Request对象request = urllib.request.Request("http://httpbin.org/")#请求对应的网站response = urllib.request.urlopen(request)# 以utf8形式解码print(response.read().decode('utf-8')) 1234567891011121314151617181920212223242526272829303132333435363738# 另外一个实例from urllib import request,parse# 请求网址url = "http://httpbin.org/post"# 头部信息headers = &#123; 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36', 'Host':'httpbin.org'&#125;## post 请求字段dict = &#123; "name":"bingwu"&#125;data = bytes(parse.urlencode(dict), encoding = 'utf8')req = request.Request(url = url,headers = headers, data = data, method = 'POST')res = request.urlopen(req)print(res.read().decode('utf-8'))# add_header 方法from urllib import request, parseurl = 'http://httpbin.org/post'mydict = &#123; 'name':'bingwu' &#125;data = bytes(parse.urlencode(mydict),encoding = 'utf8')req = request.Request(url = url, data = data, method = "POST")req.add_header('User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36')response = request.urlopen(req)print(response.read().decode('utf8')) Handler 代理123456789101112import urllib.request# 构造一个hanler对象，并创建http和https代理,用于伪装不同的ip，以防止爬虫被封proxy_handler = urllib.request.ProxyHandler(&#123; 'http':'http://127.0.0.1:8086', 'https':'https://127.0.0.1:8086'&#125;)opener = urllib.request.builder_opener(proxy_handler)response = opener.open("http://www.baidu.com")print(response.read()) Cookie 用于维持爬虫登录的一个机制1234567891011121314151617181920212223242526272829303132333435363738394041#实例1import urllib.request, http.cookiejarcookie = http.cookiejar.CookieJar()handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')for item in cookie: print(item.name + '=' + item.value)# 实例2import urllib.request, http.cookiejarfilename = 'cookie.txt'#将cookie保存成Mozilla的格式#也可以将LWPC格式的cookiecookie = http.cookiejar.MozillaCookieJar(filename)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')cookie.save(ignore_discard=True, ignore_expires=True)# 读取cookie文件中的内容，并输出cookie.load('cookie.txt',ignore_discard=True, ignore_expires=True)handler = urllib.request.HTTPCookieProcessor(cookie)openr = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')print(response.read().decode('utf8')) 异常12345678910111213141516171819202122232425262728293031323334353637# 验证 error 的错误类型import urllib.request, urllib.errortry: response = urllib.request.urlopen('http://binyong.github.io/dajkdaj.html')except urllib.error.HTTPError as e: print(e.reason, e.code, e.headers, sep = '\n')except urllib.error.URLError as e: print(e.reason)else : print('success')# 验证 error 的错误类型import urllib.request, urllib.errortry: response = urllib.request.urlopen('http://binyong.github.io/dajkdaj.html')except urllib.error.HTTPError as e: print(e.reason, e.code, e.headers, sep = '\n')except urllib.error.URLError as e: print(e.reason)else : print('success')# 验证 error 的错误类型import sockettry: response = urllib.request.urlopen("http://www.baidu.com",timeout=0.01)except urllib.error.URLError as e: print(type(e.reason)) if isinstance(e.reason, socket.timeout): print('time out')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 爬虫基本原理]]></title>
    <url>%2F2019%2F01%2F04%2FPython-crawler-fundamentals%2F</url>
    <content type="text"><![CDATA[什么是爬虫请求网站并提取数据的自动化程序 爬虫基本流程发起请求通过http向目标站点发起请求，发送一个request，可以保护额外的header等信息（一般是必要的，不然会被检测出来） 服务器响应返回一个response，其中内容便是想要获取的页面内容，如html代码，json字符串，二进制数据（图片视频） 解析内容得到的内容可能是html，用正则表达式匹配，json，直接转为json对象解析，二进制数据则保存进一步处理。 保存数据可以存为文本，或者存储到数据库中，可以指定保存文件的格式 什么是request和responseRequest 请求方式，最常用的为get，post get post 包含一个Form data，主要用于登录 head put delete options 等 请求urlurl，统一资源定位符的简称。 请求头包含了请求时的头部信息，如user-agent, host,cookies等 请求体请求时额外携带的数据，如请求的表单数据，在做post请求的时候需要。 Respons 响应状态 200 表示成功 301 跳转 404 找不到页面 502 服务器错误 响应头 内容类型 内容长度 服务器信息 设置cookie等 响应体 包含请求资源的内容 图片 二进制数据 HTML等 代码实战1234567891011121314import requestsresponse = requests.get("http://www.baidu.com")# 修改编码格式，解决命令行中可能会出现乱码的问题response.encoding = 'utf-8'print(response.text)print(response.headers)print(response.status_code)# &lt;!-- 构造请求头 --&gt;headers = &#123;&#125;headers = &#123;'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36'&#125;response = requests.get("http://www.baidu.com",headers = headers) 能抓取怎样的信息 网页文本 图片，二进制文件保存为图片即可 123456response = requests.get("https://www.baidu.com/img/baidu_jgylogo3.gif")# 输出二进制文件的内容print(response.content)with open('/tmp/1.gif','wb') as f: f.write(response.content) f.close() 视频 其他文件 解析方式 直接解析 json解析 正则表达式 beautifulsoup pyquery xpath 怎样解决JavaScript渲染问题 分析ajax请求-返回json数据 selenium/webdriver模拟浏览器请求 123from selenium import webdriverdriver = webdriver.Chrome()driver.get("http://m.weibo.com") splash,类似于selenium模拟解析 PyV8,Ghost.py 存储数据 文本 关系型数据库，MySQL等，具有特定存储内容的一个数据库 非关系型数据库，如redis，mogodb等key-value形式 二进制文件，直接存储二进制文件即可]]></content>
      <categories>
        <category>爬虫</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 数据分析环境搭建]]></title>
    <url>%2F2018%2F12%2F31%2Fpython-analysis-environment%2F</url>
    <content type="text"><![CDATA[Python基本环境搭建（Ubuntu16.04环境下）Redis 数据库安装12$ sudo apt install redis-server 完成安装即可 Redis 配置文件的修改12345$ sudo vim /etc/redis/redis.conf # 修改/etc下的redis环境配置文件/requirepass #查找requirepass 字符，找到 “requirepass forebode 默认密码为forebode，修改为自己想要的/bind 127.0.0.1 #查找“bind 127.0.0.1”，去掉前面的 ”#“符号，即可从外部环境中访问redis，否则只能在本地访问 基本操作12345678910111213141516#在配置文件修改密码之前$ redis-cli #进入redis命令行环境中，默认端口为6379# redis命令行操作set 'a' 'b' # a为键，b为对应的值get 'a' #获取'a'对应的值#修改配置文件密码之后#重启redis$ sudo service redis restart# 进入redis命令行$ redis-cli -a 'your password'set 'a' 'b'get 'a' #如果没有输入密码，则没有访问权限 Mongodb 数据库安装12345678$ sudo apt install mongodb# 启动mongodb$ mongo&gt; #进入命令行提示符&gt; show dbs #显示数据库，默认有admin，local数据库&gt; use local #切换到local数据库&gt; db.test.insert(&#123;'a':'b'&#125;) #插入一条数据 MySQL 数据库安装12345678910111213#安装mysql数据库的客户端，安装过程中会提示输入mysql root账户的密码，牢记$ sudo apt install myslq-client#命令行下访问mysql客户端,-u 代表用户root, -p 代表密码$ myslq -u root -p# 显示当前的数据库文档&gt; show databases;#切换到mysql数据库&gt; use mysql# 查看数据库下的数据&gt; select * from db# 推出MySQL&gt; exit 修改MySQL配置文件 1234$ vim /etc/mysql/mysql.conf.d/mysqld.cnf#修改其中的 bind-address = 127.0.0.1,限制本地访问；注释之后即可远程访问 Python数据分析相关的库升级pippip3 install –upgrade pip selenium驱动浏览器的一个库，主要是用来做测试。主要针对某些使用js渲染的网站，这个时候使用requests库就无法正常获取渲染内容。 用selenium就可以直接驱动浏览器，获取内容。 代码实例： 123456789import seleniumfrom selenium import webdriverdriver = webdriver.Chrome() #这个地方要注意，会报错，主要是由于没有安装chromedriver，官网下载chromedriver，然后配置文件路径，即可。driver.get("http://www.baidu.com")# 显示网页源代码driver.page_source chromedriver的安装下载chromedriver，按照下面的步骤进行即可。 123456wget -N http://chromedriver.storage.googleapis.com/2.26/chromedriver_linux64.zipunzip chromedriver_linux64.zipchmod +x chromedriversudo mv -f chromedriver /usr/local/share/chromedriversudo ln -s /usr/local/share/chromedriver /usr/local/bin/chromedriversudo ln -s /usr/local/share/chromedriver /usr/bin/chromedriver 安装PhantomJS这是一个不显示界面的浏览器。 下载phantomjs，按照chromedriver的安装一致，将chromedriver改成phantomjs即可。 注意： 现在Phantomjs已经被selenium废弃了。自己观察输出。 lxml提供xpath一个解析方式，对网页高效的一种解析方式。 beautifulsoup4也是一个网页解析的库，依赖lxml库1234567$ pip install beautifulsoup4&gt; from bs4 import BeautifulSoup# 创建一个beautifulsoup对象，第一个参数是html代码，第二个参数是解析模式&gt; soup = BeautifulSoup("&lt;html&gt;&lt;/html&gt;","lxml")&gt; pyquery这是一个类似与jQuery的一个库，语法与jQuery，完全一致。 1234567$ pip install pyquery$ python3&gt; from pyquery import PyQuery as pq&gt; doc = pq("&lt;html&gt;&lt;/html&gt;")&gt; doc = pq("&lt;html&gt;Hello PyQuery&lt;/html&gt;")&gt; result = doc("html").text()&gt; result pymysql一个操作MySQL的存储库。12345678910import pymysql# 创建一个连接，包括主机名，用户，端口，密码，数据库等信息。conn = pymysql.connect(host = "localhost",user = "root",password = "wukaiyun", port = 3306, db = "mysql")cursor = conn.cursor()cursor.execute("select * from db")#拿到MySQL中存储数据的相关内容cursor.fetchone() pymongokey-value存储形式的关系型数据库 12345678import pymongo# 声明一个mongo对象client = pymongo.MongoClient("localhost")# 声明一个newtextdb的数据库db = client("newtextdb")#声明一个表名，并插入一条数据db['table'].insert(('name':'bob'))db['table'].find_one(('name':'bob')) redis123456789import redis# 第一个参数为用户，第二参数为端口# rd = redis.Redis("localhost",6379)# 上面注释掉的是错误代码，通过help(redis.Redis()),查询到正确用法r = redis.Redis(host ='localhost',port=6379, password='')# 设定一个键值对r.set("name",'bob')# 获取数据r.get("name") flask一个web代理的库，代理的获取，存储的一个接口 123456789# flask的一个最小应用from flask import flaskapp = Flask(__name__)@app.route("/")def hello_world(): return "hello world"if __name__ == "__main__": app.run()# 在127.0.0.1:5000下查看效果 django后台管理，路由，web服务器框架，一些模板引擎，可以利用其来做一个完整的网站；分布式爬虫的维护的管理系统，可能会用到。 jupyter相当一个笔记本，支持markdown的代码记录，运行在浏览器上，可以调试运行。 依赖于很多库，其中依赖于ipython，会自动安装 使用 jupyter notebook # 自动弹出浏览器，运行在8888端口上 # 新建一个记事本 print(&quot;hello world&quot;) #ctrl + enter运行 # 按下键盘上的”b“，新增一行]]></content>
      <categories>
        <category>Python</category>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Redis</tag>
        <tag>Mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 绘制流程图]]></title>
    <url>%2F2018%2F12%2F30%2Fmarkdown-flow%2F</url>
    <content type="text"><![CDATA[流程图&amp;&amp;注意事项注意：原生的markdown不支持流程图，可以考虑使用cmdmarkdown等markdown编辑器 以下的代码使用cmdmarkdown平台实现 代码如下 12345678910st=start: Startio=inputoutput: Verificationop=operation: You Operationcond= condition: yes or no?sub= subroutine: your subroutinee= endst-io-op-condcond(yes)-econd(no)-sub-io 效果图 说明这样几行简单的代码就生成了一个优雅的流程图。流程图大致分为两段，第一段是定义元素，第二段是定义元素之间的走向。 定义元素的语法tag=&gt;type: content:&gt;url tag就是元素名字， type是这个元素的类型，有6中类型，分别为: start # 开始 end # 结束 operation # 操作 subroutine # 子程序 condition # 条件 inputoutput # 输入或产出 content就是在框框中要写的内容，注意type后的冒号与文本之间一定要有个空格。 url是一个连接，与框框中的文本相绑定]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>流程图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Snipaste 好用的截图软件]]></title>
    <url>%2F2018%2F12%2F28%2Fsnipaste%2F</url>
    <content type="text"><![CDATA[软件Logo 软件介绍Snipaste = Snip + Paste Snipaste 是一个简单但强大的截图工具，也可以让你将截图贴回到屏幕上！ Snipaste 使用很简单，但同时也有一些较高级的用法可以进一步提升你的工作效率。 Snipaste 是免费软件，它也很安全，没有广告、不会扫描你的硬盘、更不会上传用户数据，它只做它应该做的事。 软件特色功能介绍1.要截动图的话，多了解一下可能就有了～。咱截动图不行，但是贴动图可以啊，将动图右键复制（Ctrl + C）， 然后按下F3，桌面动图很nice的好不好 2.拖延症患者，对不起，F1截图之后F3自动贴图到桌面，同时右键分组收藏，做个备忘录也是可以的 3.取色器，想要一个颜色，F1截图的时候按下c，RGB格式的颜色已经存到你的剪贴板上了，直接复制就行了。 4.做教程美滋滋，截图的时候附上文字说明，任何情况下截图都OJBK 5.斗图，打开你的素材库，按下F1截图，然后配上文字，一键开启斗图模式 6.支持截图历史记录，截图的时候按下“，”或者是“.&quot;上下翻页，即可呈现你的截图历史，历史回放.... 下载地址现目前只有Window 版本和 Mac版本（公测）对于Window 版本的推荐使用Window 10系统，在Window 7 和 xp 上会遇到各种问题，在打开的时候会提示缺少东西。比较影响用户体验。 另外现在Window 10 已经很成熟了，可以考虑上车了。 对于个人用户，是免费的。无论专业版还是个人版，功能无差异；对于企业用户，专业版是收费的。 用户手册想要获取更多信息请点击用户手册，了解更多]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Snipaste</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTex入门问题汇总]]></title>
    <url>%2F2018%2F12%2F26%2Flatex-basic%2F</url>
    <content type="text"><![CDATA[系统说明平台是Ubuntu 16.04， apt install 安装的texlive。 给新手的建议 随便选一个平台，最好是找一个简单的LaTeX编辑器 不要专注与字体等美化，先熟悉基本的语法再进一步探索 关于LaTeX使用中文的解决办法直接上代码吧 1234567891011121314151617181920212223\documentclass[]&#123;article&#125;\usepackage&#123;amsmath&#125; %公式支持\usepackage&#123;CJK&#125; %导入中文字体支持包\begin&#123;document&#125;% 参考: http://www.linuxdiyf.com/linux/3476.html or http://www.latexstudio.net/archives/3561.html%gbsn为宋体中文字体代码，gkai为楷体中文，bkai为繁体中文%宋体中文测试\begin&#123;CJK*&#125;&#123;UTF8&#125;&#123;gbsn&#125;$\sum_&#123;i = 1&#125; ^n a_i = 0$,测试中文显示\end&#123;CJK*&#125;%顯示繁體中文的代碼\begin&#123;CJK*&#125;&#123;UTF8&#125;&#123;bkai&#125;顯示繁體中文\end&#123;CJK*&#125;\end&#123;document&#125; 作者、标题、日期1234567891011121314% 在begin&#123;document&#125;之前添加如下的信息\title&#123;Your title&#125; % 添加你的title名字，注意，暂时不支持中文\author&#123;Your author&#125; %添加你的author信息\date&#123;\date&#125; % \date显示今天的日期，你可以自定义输入日期，如&quot;Feb 24&quot;等% 在\begin&#123;document&#125;下首行添加,使title信息显示在文档中，否则不会有任何效果。\begin&#123;document&#125;\maketitle....\begin&#123;document&#125; 数学公式 ^ 表示上标 _ 表示下标 $... $ 单个美元符号为行内公式， \$$... $$ 两个美元符号单独为公式开一行，并居中 \begin{equation} … \end{equation}, 单独开一行并为公式编号，还有其他方法，暂不说明。 12345678910111213%在documentclass[]&#123;article&#125; 后添加如下代码，目的是为了导入数学公式支持包，可能不同平台有不同的包，暂时没有研究\usepackage&#123;amsmath&#125; %公式支持%数学公式,三种格式化% 公式的第一种表示方法，并编号\begin&#123;equation&#125;\sum_&#123;i = 1&#125; ^n a_i = 0\end&#123;equation&#125;单独开一行的公式$$\sum_&#123;i = 1&#125; ^n a_i = 0$$，这是一个行内公式，$\sum_&#123;i = 1&#125; ^n a_i = 0$ 字体加粗、斜体、下划线、强调123456789\textbf&#123;Bold&#125; ,%加粗Bold单词\textit&#123;Italic&#125; ,%将Italic变成斜体\underline&#123;underline&#125;, %给underline添加下划线\textbf&#123;\textit&#123;bold and italic&#125;&#125;, %加粗并变成斜体%强调 \emph,将会用斜体展示\emph&#123;this is a long sentence&#125; 章节和段落、目录 \section 章节 \subsection{} 子章节，注意subsection和{}之间不要有空格，不然会创建子标题失败，原因不明，应该是语法规定，可以通过语法高亮提示修正 \paragraph 段落 \tableofcontents 目录 以上都是单独的,默认编号格式为罗马数字;默认没有缩进 12345678910111213141516%为章节添加一个目录\tableofcontents %创建一个章节\section&#123; Hello section&#125;This is a section.\subsection&#123; Hello subsection1&#125;This is a subsection.\paragraph &#123; Hello paragraph&#125;This is a paragraph.\subparagraph &#123; Hello subparagraph&#125;This is a subparagraph.\subsection &#123; Hello subsection2&#125;\paragraph&#123;this is a paragraph&#125; 换行 换行使用 “\“ 1我在第一行 \\ 我在第二行\\我在第三行]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相机基本组成（尼康d5600）]]></title>
    <url>%2F2018%2F12%2F25%2FSingle-lens-reflex-camera%2F</url>
    <content type="text"><![CDATA[1. 图像传感器（CMOS） 在胶片时代，胶片就是图像传感器 在数码时代，CMOS就是图像传感器,即感光元件。 2. 感光度（ISO） 感光度，顾名思义，即感受光线的程度 这是从胶片时代继承过来的产物，在 胶片时代 感光度就是底片对光线的反应速度，即底片盒上的数字大小，对应的数字越大，对光线的敏感性越高，达到相同的亮度，所需要的 曝光时间（底片接受光线照射的时间） 也就越短。 但是有个问题，就是感光度越高，相应的拍摄出来的画质越差， 噪点越多、细节丢失、颜色偏移。所以通常选用低感光度（XXXX-XXXX） 3. 快门速度 快门，或快门单元，简单说就是一块挡在 CMOS前面的一块板子，在快门没有按下的时候，光线照不进来，按下快门的时候，打开，让光线照在 CMOS 上面,从而得到了曝光，光线转变为电信号存储在记忆卡中。 快门速度，即 快门开启的时间, 快门开启的时间越长，进入的光线越多，曝光就会增加, 快门速度也是摄影内容的一个核心n内容—— 曝光。 同时由于快门开启，底片上记录的事物会发生重叠，总的来说就是，快门时间越长，里面的东西就会越模糊，汽车光带就是这样拍摄的，通过长时间曝光 总结：，高速快门可以记录瞬间的事物，如飞溅的水滴，奔跑的宠物，运动题材的。 低速快门可以记录时间的流逝。 4. 光圈 光圈这个参数是和镜头连接在一起的。所以我们先介绍一下镜头。 4.1 镜头镜头分为 定焦镜头 和 变焦镜头。 区别： 定焦镜头的 视角 是固定的， 变焦镜头的视角是可以在一定范围内变动的。焦距： 分为广角镜头，标准镜头和长焦镜头。通俗来讲即 照大视角的， 照人像的 和 照远距离的 4.2 光圈光圈就像是人的瞳孔，和快门速度共同决定了 进光量(即进入的光线多少）。 光圈越小，单位时间进入的光线量就越少；光圈越大，单位时间内进入的光线越多。 注意： 光圈的大小和相机镜头的F值互为倒数，F值越大，光圈越小，F值越小，光圈越大 除此之外，还会影响要拍摄的照片的效果，这里涉及到一个概念，景深。 4.3 景深景深即背景的清晰度，相机得到清晰景物的深度。背景的清晰度越高，景深越大；背景的清晰度越低（虚化），景深越浅。很好理解，类比人眼，背景越清晰，即看得越远（深入）。 如何使用 拍摄人像的时候，为了突出人物（特写），选用大光圈，低景深，模糊背景，以此来凸显人物。（虚化） 拍摄花卉，表现花卉植物的某些特点。（虚化） 总结： 光圈大，虽然会有 虚化 的效果，但是有的时候在光线很充足的时候会导致过度曝光，画面失真。 光圈小，虽然能够捕获到足够清晰、锐利的照片，但如果光圈过小，由于物理光学原理，会发生 衍射,导致画面不锐利。 5. 虚化虚化三大件，焦距，拍摄距离，光圈。 焦距越长，越容易产生虚化。 拍摄距离越近，越容易产生虚化 光圈越大，越容易产生虚化 6. 全幅 or 残幅(APS-C) 由于历史原因，在数码单反相机面世的时候，CMOS的价格非常高（36 24mm），导致相机价格很贵，这个时候聪明的工程师们想出了一个很好的解决拌饭，即减小CMOS的面积（24 13mm），以降低单反的价格，以此来更好的推广单反相机。但是这又出现了一个问题，即标题所讲的 全幅OR残幅 之争，也是每一个新手在选择相机的时候面临的一个大问题。 未完待续]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>感光度</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo && GitHub Pages]]></title>
    <url>%2F2018%2F11%2F30%2FHexo-GitHub-Pages%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick InstallPlatform : Ubuntu 16.04 intall nodejs v8.9.1 ro higher12345678# install nodejs. $ sudo apt install npm # or you can visit the nodejs website download it.# clean the npm cache$ sudo npm cache clean -f# install a helper called `n`$ sudo npm intall -g n# use the `n` to install nodejs v8.9.1, which we nedd it to use the `themes/next`$ sudo n 8.9.1 Install Git1$ sudo apt install git # install the git. Install hexo12# install the `hexo` package, $ sudo npm install -g hexo-cli Init hexo12345678# create a directory ,which called `hexo`$ mkdir hexo# switch to the folder `hexo`$ cd hexo# init the folder to become the blog$ hexo init# install `node` dependency package$ npm install # or sudo npm install Quick StartCreate a new post1$ hexo new "My New Post" # then you will see a my-new-post.md in the source/_posts More info: Writing Run server1$ hexo server # or use `hexo s`,click the `http://localhost:4000` to you default browser to see the blog. More info: Server Generate static files1$ hexo generate # or use `hexo g` More info: Generating Deploy to Github Pages1$ hexo deploy # or use `hexo d` More info: Deployment Writing CategoriesIf you write the following code in you posts.md file then you will get the following scene. 1234567- Sports- Baseball- [Sports, Baseball]- [MLB, American League, Boston Red Sox]- [MLB, American League, New York Yankees]- [Movies]- [Code] Exapmle]]></content>
      <categories>
        <category>Hexo</category>
        <category>Markdown</category>
        <category>GitHub</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Writing CategoriesIf you write the following code in you posts.md file then you will get the following scene. 1234567- Sports- Baseball- [Sports, Baseball]- [MLB, American League, Boston Red Sox]- [MLB, American League, New York Yankees]- [Movies]- [Code] Exapmle]]></content>
  </entry>
</search>
