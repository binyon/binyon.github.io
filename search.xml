<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python 直接赋值、浅拷贝和深拷贝之间区别]]></title>
    <url>%2F2019%2F02%2F26%2Fpython-copy-deepcopy%2F</url>
    <content type="text"><![CDATA[内容参考http://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html 解释说明 直接赋值：其实就是对象的引用（别名），改变一个另外一个也会改变 对于可变或包含可变项的集合，有时需要一个副本，因此可以更改一个副本而不更改另一个副本，这就是浅拷贝和深层拷贝出现的原因 浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的（可变）子对象，父对象是独立的，但是子对象的指向是相同的，采用对象的引用 深拷贝(deepcopy)： 需要导入copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象，两者是独立的 代码实例123456789101112131415161718192021222324252627# 赋值引用# a对象是一个字典，字典的值是一个列表，是一个`可变对象`a = &#123;1:[1,234,3]&#125;b = a# 给b的值中增加一个元素b[1].append(2)# 输出a，b的值print(a,b) # &#123;1: [1, 234, 3, 2]&#125; &#123;1: [1, 234, 3, 2]&#125;# 浅拷贝,深拷贝import copya = [1,12,3,2,['a','b']]b = a.copy() #或者导入copy模块,使用copy.copy(a)c = copy.deepcopy(a)a.append(5)a[4].append(2)print('a = ', a) #a = [1, 12, 3, 2, ['a', 'b', 2], 5]print('b = ', b) #b = [1, 12, 3, 2, ['a', 'b', 2]]print('c = ', c) #c = [1, 12, 3, 2, ['a', 'b']]]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[搜索技巧]]></title>
    <url>%2F2019%2F02%2F23%2Fweb%20search%20skills%2F</url>
    <content type="text"><![CDATA[短语搜索 搜索引擎对于用户检索的关键词并不会进行完全匹配搜索，对于多个关键词的检索一般会进行单个关键词的检索而给出结果页面，造成我们搜索到额结果不符合预期，从而费力去手动去筛选信息，这并不符合我们的工作高效率的原则。Google给我们提供了一种方法，叫做短语搜索的。通过给你的几个关键词加上引号，搜索得到的结果将会和你的关键词完全匹配，包括关键词的顺序都一致。 模糊搜索，~Link，查询与这个网站祥光的的网站信息Site，查询该域名小的所有网站信息，site:youku.com尽量少使用all开头的特殊匹配字符查询。 &quot;&quot; 双引号将要搜索的内容放入双引号中，代表完全匹配要搜索的内容，并且顺序一致。 - 减号排除减号后面的内容，减号前面有空格，后面没有空格，如“搜索 -引擎”。相应的还有加号“+”可以在但是不强制要求，可以使用空格代替，一般用于多个关键词检索，减小搜索范围，排除其他出现的干扰词 通配符*表示任一的意思，遇到有什么东西记得不清楚了可以采用这种方法模糊搜索，如“不见黄河之水”“蜀*难” inurl如“inurl:搜索引擎优化”，表示在搜索的网址中的包含后面的关键词“搜索引擎优化”，而不是网页内容中包含后面的内容，一般出现的是如百度百科，维基百科之类的网页词条介绍 inanchor锚链接内容搜索，计算机专用的术语，表示一个锚中出现有后面的内容的词语，可以理解为链接的别名，但是最后的搜索结果不一定包括有后面你要求的内容。如“inanchor：登陆” intitle搜索网页html title标签包含的内容，主要用于专业人士使用。如“intitle:豆瓣” allintitleintitle的进阶版本，用于title标签中的多个关键词搜索，如“allintitle:豆瓣 知乎 区别” allinurlinurl的进阶版，“allinurl:豆瓣 知乎”就相当于“inurl:豆瓣 inurl:知乎” filetype指定特定文件搜索类型，如“filetype:pdf c语言”，“filetype:docx 食品健康”主要用于资源的搜索，像视频种子资源的搜索之类的 site指定搜索的站点，在特定的网站内搜索，如“site:youku.com 一路向西” relatedrelated:youku.com 返回的是与优酷有关的网站，排除了优酷网站本身，具体相关性无法考证，只适用于Google ~模糊匹配搜索，在前面或者是后面。 以上的命令都可以互相组合后再用]]></content>
      <categories>
        <category>实用技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对按摩保健的认识]]></title>
    <url>%2F2019%2F02%2F21%2FMassage%20Care%20paper%2F</url>
    <content type="text"><![CDATA[经过了半个学期九周时间对按摩保健的学习，我学习到了什么是按摩，知道了什么是按摩什么是推拿，以及按摩的作用和好处，同时了解了它的常见手法。 在认识按摩的保健作用之前，我们需要知道什么是按摩，以及按摩和我们常说的推拿之间有什么区别。 什么是按摩按摩是运用手、指的技巧，在人体皮肤、肌肉组织上连续动作来达到缓解身体病症和缓解疲劳的目的，具有一定的治疗作用。这种方法，叫做按摩疗法。按摩的法语为（Massage），直译过来就是我们常说的“马杀鸡”，我们日常说的“走啊，马杀鸡去”，就是说去按摩。 按摩是以中医的脏腑、经络学说为理论基础，并结合西医的解剖和病理诊断，而用手法作用于人体体表的特定部位以调节机体生理、病理状况，达到理疗目的的方法，从性质上来说，它是一种物理的治疗方法。从按摩的治疗上，可分为保健按摩、运动按摩和医疗按摩。而同一种按摩中又分为很多种，如运动按摩中，有运动前按摩和运动后按摩，训练前按摩等，通过这些方法能够促进运动员身体、心理达到一个良好的状态，增强训练效果和提高体育成绩，是按摩在运动中的一个很好的实际运用。 按摩的历史从历史上来来说，按摩可以追溯到原始社会。在原始社会，原始人在生产劳动时或与野兽搏斗中，必定有一些外伤发生。出现疼痛，他们自然地用手去抚摸，按揉逐步收到效果；当人体的某一部位受到损伤出血时，人们便本能地用手按压以止血；当损伤使局部部位隆起时，人们又本能地通过抚摩、揉动使隆起变小或消失，从而缓解了肿痛。另外人们发现，用石片等刮擦某些部位能缓解一些特定的病痛，人类本能地重复应用一些能够祛病的抚摸按揉手法，经过时间的延续，这些手法得到发展和积累。在长期的认识实践过程中，按摩逐渐从无意识的偶然动作演变成为人们自由运用的系统的治疗方法。约在几千年前，我国祖先就为按摩奠定了基础，随着后来人们对于人体的认识逐步加深以及后来医学的进步，这些手法就逐步形成了我国的按摩学科。 按摩的手法按摩是古称，我国在明代以前是将按摩和推拿统称为按摩，而明代之后就将其改名为推拿。这不但是简简单单的名称的变化，而是表示人们对于按摩这一手法的发展和人们对于这一手法的认识的提高。早期的按摩疗法仅用于少数疾病的治疗，手法种类也很少，常用的是按和摩两种手法，按法是单纯的向下用力，即所谓“按而留之”，摩法则是在体表作环行摩擦，属平动的范围。以后随着治疗范围的扩大，手法也相应有了发展，除了按法、摩法等常用手法外，又出现了推法。推法虽也属平动类手法，但却是一种有方向性选择的直线摩擦手法，因此对疾病的治疗更有针对性。在实践中，人们发现手法用力方向的不同对疗效有一定的影响，从而产生了各种用力方向不同的手法。除向下的压力外，还有向上的提力以及相对用力的挤压等。手法的分类也逐渐合理，适应症也逐渐扩大，按摩这一名称逐渐被推拿这个更为明确的概念所取代。可以说由按摩改称推拿，标志着推拿发展史上的一个很大的飞跃。 什么是推拿按摩侧重于保健和疲劳的消除，而推拿更加侧重于疾病，现代医院中只存在推拿科，而按摩则是普遍存在于民间的社会机构中。同时相关的从业人员的叫法也不一样，从事按摩的的多以盲人按摩师为主，经过短时间的培训，通过劳动局颁发的上岗证就可以持证上岗工作了。而推拿的从业人员需要专科学历，他们当中大多数医学院出身的，其中不乏硕士、博士、博士后、他们当中还有主治医师、主任医师、教授等。同时要具备有行医资格，需要通过国家执业医师考试，相对于按摩来说，对从业人员的要求较高、较严格。 保健按摩是用按摩手法达到养身保健目，是中医保健方法之一，以健身防病为主，诊治病伤为辅。推拿（治疗按摩）包括伤科推拿，是中医外治疗法之一，是应用推拿手法达到治病目的的物理疗法，人类最古老的一种是治疗疾病的方法，以诊治疾病为主，健身防病为辅。 按摩和推拿手法的区别按摩和推拿的手法也有很大的区别。按摩只是简单的手推或者是按捏，主要是按、摩、揉、弹、叩、敲等，家庭成员通过简单的学习就可以相互按摩。同时按摩力度基本没有什么变化，只能触及皮肤或者是肌肉组织的表层，对于更加深层的病灶没有良好的治疗效果。推拿手法的要求是柔和、均匀、有力、持久，针对穴位达到深透。针对不同的疾病，身体的不同部位有不同的推拿手法和技巧。推拿具有舒经通络、促进气血运行、调整脏腑功能、润滑关节、增强人体抗病能力等作用。对运动系统、神经系统常见疾病的治疗，效果非常明显。对一些慢性病也可以作为辅助治疗，如消化不良、便秘、胃病等。要求推拿医师都应具备完整的医学常识如解剖、生理、放射医学等和专业知识，不是人人皆可为之的。 按摩的作用我们知道了按摩和推拿之间的区别以及应用范围，那么按摩保健有什么作用呢？根据名称来说，可以确定的是有保健作用的。那么具体是在那些方面呢？一些就是一些按摩的常见的保健作用。 根据现代医学的认识，按摩对肌肉、关节、韧带、肌腱、心血管，神经系统，呼吸系统，消化系统，泌尿生殖系统等有显著的作用。下面是具体的作用。 对肌肉的作用，改善肌肉的营养代谢，增强肌肉张力和弹性，使血液，淋巴回流加快，加快血乳酸的清除，促进疲劳的恢复，促进胶乳中致痛、致炎物质的分解和稀释，使炎症消退，提高“痛阀”，释放“阿片”样物质，有明显的镇痛作用，可延长肌肉的有效作用时间，延长肌肉老化时间。对关节，韧带，肌腱的作用，可消除关节内炎症及积液，可促进损伤肌肉和肌腱的恢复，恢复弹性和柔韧性，松解关节粘连，恢复关节功能，可使关节局部温度升高，治疗冷痛症。 对心血管的作用，能促进损伤组织血管网的重建，有利于损伤组织的修复，可使血液动力学得到改善，改善血粘度，减缓血管硬化程度，改善微循环和脑循环，降低血管外阻力，能改善心肌缺血状态。 对神经系统的作用，可调节大脑皮层的兴奋与一直过程，可使末梢神经的兴奋性降低，镇痛作用，可使神经性疲劳得到快速恢复。 对呼吸系统的作用，调整胸隔、肺的状态，从而产生镇咳、平喘、化痰的作用，可加深呼吸、增加氧气的吸入和二氧化碳的排除、修复肺的弹性，使呼吸肌发达，增加肺活量。 对消化系统的作用，可使消化腺分泌增加，促进消化吸收，对胃肠道消化功能调整作用，治疗腹泻和便秘，可促进胆囊的排空能力，可抑制平滑肌的痉挛。 对泌尿生殖系统的作用，可调节膀胱张力和括约肌的功能，对女性月经周期有明显的调节作用，促进乳腺发育、分泌、预防乳腺增生，有改善性功能的作用。 知道了按摩的好处之后，我们应该怎样来进行日常的按摩保健呢？我们只需要记住下面的这些口诀就好了，发常梳，面常檫，目常运，鼻常揩，齿常叩，耳常弹，腹常摩，腰常拍，足常搓，肢常摇。 按摩的注意事项在按摩中我们有以下需要注意的事项，注意事项： 按摩前要修整指甲、热水洗手，同时，将指环等有碍操作的物品，预先摘掉。 态度要和蔼，严肃细心，要耐心地向患者解释病情，争取患者合作。 患者与医生的位置要安排合适；特别是患者坐卧等姿势，要舒适而又便于操作。 按摩手法要轻重合适，并随时观察病人表情，使患者有舒服感。 按摩时间，每次以20～30分钟为宜，按摩次数以十二次为一疗程。 患者在大怒、大喜、大恐、大悲等情绪激动的情况下，不要立即按摩。 饱食之后，不要急于按摩，一般应在饭后二小时左右为宜。 按摩时，有些患者容易入睡，应取毛巾盖好，以防着凉，注意室温。当风之处，不要按摩。可以由他人按摩，也可以自我按摩。 当然按摩不是万能的，对于有些严重疾病症状，我们不要盲目相信按摩，而要及时送医院，以免耽误最佳的治疗时间，造成人生的悲剧。 个人感悟通过半个学期，18节课的学习，其实没有学习到很多的关于按摩手法的具体知识，学到的更多的是关于认知方面的。其中有这样的一种手法，在腹泻的时候，通过按摩的摩法，逆时针在腹部按揉，可以缓解腹泻的症状，其实这样的手法和物理是相同的，腹泻不就是食物流经小肠的时候速度太快了吗，通过逆时针按摩的方法，可以在一定程度上减缓它的流动速度，从而达到缓解腹泻症状的效果。 通过这样的学习我了解到了，学科知识之间是相互连通的，以前我们学过的东西物理、化学、生物学等知识就在这上面排上了用场，有了用武之地。 在我看来按摩就是通过外力，物理的方法刺激身体的退化或者是老化的肌肉组织等重新恢复活力的一种方式。达到保证身体的正常生命活动的进行。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Windows 10 中Ubuntu子系统 文件互访]]></title>
    <url>%2F2019%2F02%2F18%2Fwindow10-sublinux%2F</url>
    <content type="text"><![CDATA[简单的说，Windows的系统盘被挂载到了/mnt目录下, 我们用命令 wsl 系统安装的linux子系统, 使用 cd /mnt 切换到对应的目录, 使用ls命令列出当前的目录下的文件夹,可以看到就是我们的两个系统盘的盘符,我有两个盘,一个C盘和一个D盘. //todo 我们成功切换到了系统盘之后, 可以直接在bash中使用各种linux下的命令,如mv, cp, 等一系列命令. 也可以切换到对应的目录编辑文档. 比如说我这个博客就是在Ubuntu下建立的,现在切换到Windows平台下, 使用wsl就可以完成以前在Ubuntu上的操作.没有任何差别. 如果有差别的话,就是编译速度有点慢,git下载速度慢,系统资源占用比较多]]></content>
  </entry>
  <entry>
    <title><![CDATA[社会契约论经典]]></title>
    <url>%2F2019%2F02%2F08%2FDu%20Contrat%20Social%2F</url>
    <content type="text"><![CDATA[人性首要的法则是要维护自身的生存，人性首要的关怀是对自己的关怀。 强力导致了奴隶的出现，而怯懦则使他们永远当奴隶。 为了利益转让自由。纵使人们能够转让自己的权利，但是他也无法转让自己孩子的自由和权利。孩子生来是自由的，他们的自由是属于自己的，任何人都没有权利堆对他们进行处置。只能在孩子清醒作用理智之前父亲可以为了他的生存，幸福，商定某些契约。但是却不能将他们无条件奉送给别人，因为这种奉送违反了自然的目的，而且超出了作为父亲的应有权利。 放弃自由就等于是放弃了自己作为人的资格，放弃人的权利，甚至是放弃自己的义务。而一个放弃自己义务的人是无法得到任何补偿的。这种弃权是不和人性的，并且取消了意志的自由，也就相当于取消了行为的一切道德性。最后。规定一方为绝对的权威，另一方无条件的服从，这本身就是一项无效且自身矛盾的约定。 和平是一种状态，人处于原始独立状态的时候，彼此之间绝不存在任何的经常性的关系能够构成和平状态或者战争状态，所以他们绝不可能是天生的仇敌。构成战争的是物而不是人的关系。私下的决斗，斗殴，或者是冲突，这些行为都无法构成一种状。因此战争是一种国与国之间的关系，而非人与人之间的一用关系。在战争中，个人与个人绝非以人的身份，甚至则也不是以公民的身份，而仅仅是以士兵的身份才偶然成为仇敌的，他们只是国家的保卫者，而绝不是作为国家的成员。最后，只要我们不能在性质不同的事物之间确定任何关系，一个国家就不能以人为敌，而只能以其他国家为敌。 生存危机使人类联合在一起，达成了人类历史上的第一次全体同意，并最终导致了少数服从多数的结果的出现。这就是对社会上存在的少数服从多数的理解。 一旦人群结成了一个共同体，侵犯其中任何一个成员就被看做是在侵犯整个共同体，而侵犯共同体就使得共同体成员同仇敌忾。如此一来，基于义务和利害的关系就迫使缔约者双方互助，而同时这些人也就应竭力使相关的利益在这种双重关系之下结合在一起。 个人力量为标志的自然自由，自己被公共意愿约束的社会自由]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一篇记录git使用的方法]]></title>
    <url>%2F2019%2F01%2F24%2Fgit-use%2F</url>
    <content type="text"><![CDATA[Git 是什么?Git 获取安装//Todo Ubuntusudo apt-get install git Windows 7 orhigher推荐使用 gitforWindows 提供的git工具,百度搜索第一个就是. Git 使用前配置启动Ubuntu 下不需要多余的配置,安装之后打开terminal即可 Windows下默认安装不需要配置, 直接运行git bash即可. Git 初始化先创建一个文件夹, 通过命令行的形式 cd your_dir 进入输入命令 git init init表示初始化,表示创建一个空的Git 仓库, 或者是重新初始化一个已经存在的 Git 仓库 123456# 创建一个git学习文件夹然后进入$ mkdir git_learn$ cd git_learn# 初始化git_learn为一个git仓库$ git init Git 使用前配置学习资料12345git clone https://github.com/iissnan/progit.git progitcd progitnpm install 初始化分支1234567$ git init #运行此命令之后会在当前的目录中出现一个.git文件夹$ git add *.c *.py # 把当前目录中的.c,.py文件纳入版本管理系统中。即将其放入暂存区域，把未进行追踪的文件进行追踪$ git add README$ git commit -m "initial project version" 从现有仓库克隆123456# 克隆远程的hexo仓库，并在本地命名为myhexo$ git clone git://github.com/binyon/hexo.git myhexo$ git status #查看当前的状态，有多少个分支，目录，记录$ git add *.c # 如果多次修改的话，则需要将其多提add操作，否则它将只会记录你之前提交的那个时间点上的修改。 gitignore 文件1234# 将不需要追踪的文件放入里面，如 .[oa], .[c]等文件， *~忽略以波浪号结尾的文件。# 说明# 以#开头的或者是空行的都会被忽略, 匹配模式下的跟反斜杠表示要忽略的是目录, 要忽略指定匹配模式以外的文件,在前面加上反引号(!) 举例说明如下 # 这个是注释,将被.git忽略 # 忽略所有以.a结尾的文件 *.a # 但是lib.a除外 !lib.a # 仅仅忽略Todo下的所有文件,但不包括subdir/Todo /Todo # 忽略build目录下的所有文件, build/ # 会忽略doc/notes.txt,但是不包括doc/server/server.txt doc/*.txt # 忽略所有的在doc目录下的txt文件 doc/**/*.txt git status and git diffgit status仅仅只能列出修改过的文件,但是针对具体的修改了那一部分的话需要使用git diff命令 12345678910# 查看当前文件与暂存区中的对照$ git diff# 查看暂存起来的和上次提交之间的差异,也可以使用git diff --staged$ git diff --cached# 提交运行,运行此命令将会调用默认的编辑器来编辑提交记录$ git commit$ git commit -a #会将所有已经在追踪过的文件提交,跳过git add环节 移除文件移除文件,就是要将其不要被git追踪,移除之后将会出现在未追踪清单中”changes not staged for commit”部分. 12345678910111213$ rm .git# 查看状态$ git status # 在状态中将会显示deleted : .git# 记录这次移除$ git rm "filename"### 注意:如果之前在删除之前放入暂存区,则需要使用强制命令,-f删除# 另一种情况# 把文件从git中删除追踪,但是保留之前提交的文件.$ git rm --cached readme.txt$ git rm log/\*.log 移动文件说明:git并不追踪文件移动操作. 123456$ git mv file_from file_to#说明上面命令相当于运行了以下的三个命令$ mv file_from file_to$ git rm file_from$ git add file_to 远程仓库的使用在克隆完一个git项目之后至少会有一个origin的远程库 12$ git remote # origin$ git remote -v # -verbose 查看对应的地址 添加远程仓库1234$ git remote add [shortname] [url] # 用shortname来指代url对应的仓库$ git fetch [shortname] 从远程仓库获取数据123456$ git fetch [remote-name]### 注意,下面命令会取得你从上次克隆之后的所有更新文件,但是不会自动合并.$ git fetch origin $ git pull #会自动合并, 推送到远程仓库12# 默认使用origin 和 master$ git push [remote-name] [branch-name] 删除远程分支语法, git push [远程名] [本地分支]:[远程分支] 如果你想要在服务器上删除远程分支backup,1$ git push origin :backup 创建git分支123456789101112131415$ git checkout -b backup# 以上命令等同于$ git branch backup$ git checkout backup$ git checkout master$ git merge backup # 合并两个分支$ git branch -d backup # 合并之后不需要就删除这个分支# 合并时遇到冲突$ git status #查看问题出现在哪$ git add #解决问题之后将其标记为已解决$ git mergetool # or opendiff，调用默认工具合并]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Conda 基本使用方法]]></title>
    <url>%2F2019%2F01%2F23%2Fconda-use%2F</url>
    <content type="text"><![CDATA[conda简介conda使用 命令行模式使用 123456789101112131415161718192021222324# 查看当前的conda环境conda info -e# 查看conda帮助conda -h# 查看conda下的create帮助conda create -h# 列出当前的conda环境conda env list #创建一个3.6版本的conda环境conda create --name Python36 python=3.6# 激活上面创建的conda环境conda activate Python36# 退出上面的环境conda deactivate#删除上面创建的conda环境conda remove --name Python36 --all anaconda-navigator交互模式使用 支持选项比较少，只有create，import和remove三个选项。创建和删除的时候只需要输入环境的名字即可。 conda环境安装位置默认在anaconda安装路径下的envs目录下，各个平台都相同。]]></content>
      <categories>
        <category>Conda</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Conda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android-studio 踩坑纪实]]></title>
    <url>%2F2019%2F01%2F23%2Fandroid-studio%2F</url>
    <content type="text"><![CDATA[版本号android studio v3.2.1 Android studio 初次安装坑下载问题在国内，安装Android studio可以说是相当麻烦的，除了要费尽心力去下载Android studio的安装包，还要面对安装Android studio过程中下载Android sdk的麻烦。 由于是校园网，支持ipv6，不知道外面能否直接访问Android官网下载Android studio，就不考虑这一步吧。 虽然有ipv6加持，但是在安装Android studio过程中还是会遇到下载Android sdk的问题，依然是无法访问Google。 解决方法 方法一 github上下载xx-net,按照官方文档安装 Android studio 提示无法下载的时候，设置proxy代理，代理到xx-net上。host：127.0.0.1，port：8086 下载安装，会比较慢。注意:这个方法问题比较多,可以尝试方法2. 但是这不失为一种科学上网的方法. 方法二 选择国内镜像, 可以参考如下链接的回答, 国内镜像使用, 主面板右下角的Configure –&gt; settings –&gt; Appearance &amp; Behavior –&gt; System Settings –&gt; HTTP Proxy，选中Auto-detect proxy settings，勾选下方Automatic proxy configuration URL，填入国内的某个镜像站。这里，我选择的是mirrors.neusoft.edu.cn:80。 Android studio 初次编译坑安装好Android sdk之后还有一个问题，新建helloworld工程之后，要使用gradle编译。 解决办法如果是使用上面的方法一下载Android sdk，那么遇到gradle编译失败时，需要考虑将代理修改回原本的设置。gradle在配置的时候会默认使用原来的网络代理，且一直使用，这个需要手动修改。 因为gradle官网是可以访问的，不需要设置代理，代理之后会出现各种问题。以下为修改方案 找到工程下的Gradle的gradle.properties，注释掉： // 这是我用xx-net代理的配置 systemProp.https.proxyPort=8086 systemProp.http.proxyHost=127.0.0.1 systemProp.https.proxyHost=127.0.0.1 systemProp.http.proxyPort=8086 或者是有http代理，但是没有https代理，对应添加https代理 Android studio运行坑完成编译之后, 对于初学者来说最重要的是看到我完成了什么, 通过运行可以进一步增加我们的成就感. 那么在运行项目的时候, 有那些需要注意的呢? 12电脑内存过小的话, 8 g 起步吧. 就不推荐虚拟机运行,需要下载镜像,这是比较麻烦的,而且运行速度慢,还需要编译推荐使用电脑usb连接手机, 开启usb调试模式, 直接就在手机上编译运行了,对于编译速度来说相当有保证.]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android studio</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 再次入门记录]]></title>
    <url>%2F2019%2F01%2F23%2Fpython-new%2F</url>
    <content type="text"><![CDATA[Python的解释器Python有多种解释器。 Cpython其中默认的是cpython，是用c语言写的Python解释器。有历史背景，开发Python这门编程语言的时候，c语言占据了编程世界的主要地位，且运行速度快，更接近硬件底层。所以。 提示符为： &gt;&gt;&gt; Ipythonipython，全称可以理解为interaction python，可以实时展示Python的运行效果。 提示符为： ln[序号]： == 推荐使用jupyter notebook 记录编码过程和做笔记 == PyPyPyPy 是另一个 Python 解释器，它的目标是执行速度。 PyPy 采用 JIT 技术，对 Python 代码进行动态编译（注意不是解释），所以可以显著提高 Python 代码的执行速度。 JythonJython 是运行在 Java 平台上的 Python 解释器，可以直接把 Python 代码编译成 Java 字节码执行。 IronPythonIronPython 和 Jython 类似，只不过 IronPython 是运行在微软.Net 平台上的 Python 解释器，可以直接把 Python 代码编译成.Net 的字节码。 小结Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性。 Python 编辑器编辑器之争对于Python的编辑器有太多选择了, 有各种IDE,还有各种文本编辑器. 但是对于初学者, 我们需要的是对于Python的基本语法快速熟悉. 不要在细枝末节上做纠结, 导致舍本逐末. 这里我推荐使用 thonny 这个专门为Python初学者开发的编辑器, 足够简单, 功能也足够强大. Thonny 具备自动补全 具备一定的debug功能 可靠的包管理器,集成pip 集成最新的python3 有错误建议 等到该编辑器不够使用之后再进一步学习 ide 的使用吧. (可以使用pycharm) 基本语法输入和输出1234567# 输出 dog cat pig, 用逗号分割print('dog ' , 'cat ', 'pig')# 输入youIn = input("please input some chacter: ")# 两种格式化输出方式print("you input is %s", youIn)print("you input is :%s" % (youIn)) 格式化输出 TODO缩进\注释缩进一般使用 Tab , 四个空格. 有助于写出格式化的代码,但是当复制代码的时候就很麻烦. 使用ide很难格式化Python的代码. 空格和Tab一定不能混用 , 混用之后很麻烦.初学者一般是在这里出错. 注释 使用 #, 单行注释. 使用三个单引号或双引号, 多行注释 1234567891011121314151617181920212223# 这是一条单行注释'''这是几条多行注释,一般用于文件开头,说明作者, 代码意图, 写代码时间等.'''"""这也是多行注释这也是多上注释"""# 上面的两条代码也可以用于多行输出,试试如下代码print("""这也是多行注释这也是多上注释""")print('''这是几条多行注释,一般用于文件开头,说明作者, 代码意图, 写代码时间等.''') Python 面向对象编程面向对象的概念面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向对象程序设计将程序拆分成一系列的命令集合, 为了简化复杂度, 将一个复杂的函数拆分成各种简单的函数. 即 大函数 -&gt; 小函数 面向对象程序设计将程序拆分成多个对象的组合, 一个对象可以处理另一个对象传递过来的数据. Python中所有的数据类型都是对象. 面向对象思想面向对象的设计思想是抽象出Class，根据Class创建Instance 面向对象的抽象程度比函数要高, 既包含数据, 也包含处理数据的方法. 类起一个模板的作用, 必须包含基本的属性. 实例创建一个类的基本方法12345678910111213class #表示声明一个类,后面紧跟类名. 类名通产是大写开头.object # 表示该类是从那个类继承下来的, 是所有的类都会继承的. 没有明确继承就写object.# 基本构造class Student(object): pass# 通过__init__ 方法, 绑定属性, 起到模板作用.class Student(object): # self 表示创建的实例本身 def __init__(self, name, score): self.name = name self.score = score 处理学生成绩 函数方式处理对应的数据 1234567# 需要处理的数据std1 = &#123;'name':'Tom', 'score':81&#125;std2 = &#123;'name':'Mac', 'score':90&#125;# 打印学生成绩def print_score(std): print('%s : %s' % (std['name'], std['score'])) 面向对象思想处理学生成绩实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Student(object): # 数据 def __init__(self, name, score): self.name = name self.score = score # 函数 -&gt; 类的方法, 调用student类自身的函数, 打印成绩 def print_score(self): print("%s : %s" % (self.name, self.score) ) # 创建一个新方法 def get_grade(self): if self.score &gt;= 90: return 'A' elif self.score &gt;= 60: return 'B' else: return 'C'# 面向对象代码, 传入与 __init__ 方法有相同属性的实例.bart = Student('Bart Simpson', 59)lisa = Student('Lisa Simpson', 87)bart.print_score()lisa.print_score()# 直接在外部修改student实例的score属性值&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; lisa = Student('Lisa Simpson', 87)&gt;&gt;&gt; bart.score = 5050&gt;&gt;&gt; bart.score = 70# 限制外部代码修改实例的name, score 属性# 通过双下划线(`__`)将其属性变成私有变量, 以达到拒绝外部访问的效果# 对于单下划线的变量虽然可以直接访问,但是我们将其视作私有变量, 不要随意访问# __variable__ 这种变量是特殊变量, 可以直接访问def __init__(self, name , score): self.__name = name self.__score = scoredef print_score(self): print('%s :%s' % (self.__name), self.__score)# 获取对应的属性值def get_name(self): return self.__namedef get_score(self): return self.__score# 修改内部的属性值def set_name(self, name): self.__name = namedef set_score(self, score): self.__score = score# 双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量&gt;&gt;&gt; bart._Student__name"bart"# 注意以下的一种错误写法&gt;&gt;&gt; bart.__name = 'bart 2'&gt;&gt;&gt; bart.__name'bart 2'# 看似成功修改了__name的属性值, 可是调用如下方法却会发现没有修改&gt;&gt;&gt; bart.get_name()'bart' 对象(Class)和实例(Instance) 对象Class 即一类事物的合集, 是一种抽象概念. 具有同一特性的一类事物的总称. 如所有的 Student(Class) 实例Instance 即一类事物中的一个具体存在的个体, 是实际存在的一个. 如一个叫 Tom(Instance) 的 Student(Class) 方法和函数的区别方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据 继承和多态 继承 12345678910111213141516171819202122232425# 假设我们定义了一个Animal类# 父类, 被继承的类class Animal(object): # animal run method def run(self): print('animal\'s run...')# 子类,继承自Animal, 所有的对象都继承自object, 自动拥有了父类的所有方法class Dog(Animal): pass# 测试代码xiaohaung = Dog()# 这里我们虽然在dog类中什么都没做, 但是依然具有run方法, 这就是继承xiaohuang.run()# 类型检查, 子类可以看做是父类, 但是父类不能看做是子类. # 比如 黄种人是人, 但是人不一定是黄种人.isinstance(xiaohuang, Animal) # Trueisinstance(xiaohuang , Dog) # True# 但是animal = Animal()isinstance(animal, Dog) # false 多重继承 对于不同事物，我们有不同的分类，各种分类方式之间可能完全不交叉，也可能有所交叉当我们进行程序设计的时候，如果要给每一个类都进行划分，对于不同的类又有不同的功能。我们很难穷举出所有的分类来。在此我们采用多重继承的方式来解决这个问题 12 多态 1234567891011121314151617181920# 我们重写子类中的run方法class Dog(Animal): def run(self): print("dog is run...")xiaohaung = Dog()xiaohaung.run()# 输出结果表示子类的run方法得到了运行, 父类的没有被运行.# 因为代码在运行的时候总是会优先使用子类有了的方法.# 以上是多态的一种# 多态的好处def print_run(Animal): Animal.run() Animal.run()# 测试print)run(xiaohuang)animal = Animal()print_run(animal) 以上例子说明我们不用修改代码, 通过传入不同的类就能获得不同的输出结果. 获取对象信息我们拿到一个对象的时候, 如何知道这个对象是什么类型, 有什么方法 type()对于基本类型, 使用type()函数判断对象类型 123456789101112&gt;&gt;&gt; type(123), type('str')&lt;class 'int'&gt;, &lt;class 'str'&gt;&gt;&gt;&gt; type(int), type(str)&lt;class 'type'&gt;, &lt;classs 'type'&gt;&gt;&gt;&gt; type(None)&lt;class 'NoneType'&gt;# 对于内置的函数&gt;&gt;&gt; type(abs)&lt;class 'builtin_function_or_method'&gt; 判断一个对象是否是函数, 可以用一个types库中的函数123456789101112&gt;&gt;&gt; import types&gt;&gt;&gt; def fn(): pass# 自定义函数类型&gt;&gt;&gt; type(fn) == types.FunctionTypeTrue# 内置函数类型&gt;&gt;&gt; type(abs) == types.BuiltinFunctionTypeTrue# 生成器类型&gt;&gt;&gt; type(x for x in range(10)) == types.GeneratorType 对于类的继承关系来讲, 使用isinstance()object -&gt; Person -&gt; YellowPerson -&gt; SichuanPerson 使用isinstance() 可以判断继承关系, 也可以替代type()函数, 所以我们总是优先使用isinstance(). 1234567891011121314151617181920212223242526272829303132333435# 判断基本类型&gt;&gt;&gt; isinstance('123', str)True&gt;&gt;&gt; isinstance(123, int)True# 判断变量是否是多个类别中的一种&gt;&gt;&gt; isinstance([12,3], (tuple, list))True&gt;&gt;&gt; isinstance(&#123;'name':bin, 'age':12&#125;, (dict, list))True# 判断继承关系&gt;&gt;&gt; class Person(object): def say(self): print("I'm a person")class YellowPerson(Person): def say(self): print("I'm a yellowperson")class SichuanPerson(YellowPerson): def say(self): print("I'm a sichuanperson") &gt;&gt;&gt; person = Person()&gt;&gt;&gt; yellowPerson = YellowPerson()&gt;&gt;&gt; sichuan = SichuanPerson()&gt;&gt;&gt; person.say()I'm a person&gt;&gt;&gt; yellowPerson.say&lt;bound method YellowPerson.say of &lt;__main__.YellowPerson object at 0x7f3f4d2de630&gt;&gt;&gt;&gt;&gt; yellowPerson.say()I'm a yellowperson&gt;&gt;&gt; sichuan.say()I'm a sichuanperson 使用dir()dir() 用于获得对象的所有方法和属性. 尤其是当不知道对象具有什么属性的时候123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt; dir(person) # 一长串, 自定义的方法出现在最后# 配合hasattr(), getattr(), setattr() 函数, 可以很方便的为对象添加属性和方法# 一个完整演示 dir(), hasattr(), getattr(), setattr()的例子&gt;&gt;&gt; class MyPower(int): def __init__(self, x): self.x = x def power(self): return self.x * self.x &gt;&gt;&gt; obj = MyPower(2)&gt;&gt;&gt; obj.power()4&gt;&gt;&gt; hasattr(obj, 'x') # obj 有x属性吗True&gt;&gt;&gt; getattr(obj, 'x') # obj2&gt;&gt;&gt; getattr(obj, 'x') # 获取obj.x对应的属性值, 如果没有这个属性则会报错2&gt;&gt;&gt; setattr(obj, 'y')Traceback (most recent call last): File "&lt;pyshell&gt;", line 1, in &lt;module&gt;TypeError: setattr expected 3 arguments, got 2&gt;&gt;&gt; setattr(obj, 'y', 12)&gt;&gt;&gt; setattr(obj, 'y', 12) # 设置obj的属性值&gt;&gt;&gt; hasattr(obj, 'y')True&gt;&gt;&gt; getattr(obj, 'y')12&gt;&gt;&gt; dir(obj) #列出obj的所有属性和方法['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dict__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__module__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'power', 'real', 'to_bytes', 'x', 'y']&gt;&gt;&gt; dir(obj) #列出obj的所有属性和方法 Python 面向对象高级给实例增加属性和方法123456789101112131415161718192021222324# 正常情况下我们创建了一个class类，由于动态语言的灵活性#我们可以给其实例添加任何属性和方法。具体如下class Student(object): pass# 测试# 给实例添加属性s1 = Student()s1.name = 'bing's1.age = 12# 打印输出对应的名字和年纪print(s1.name, s1.age)# 给实例添加方法# 先定义一个方法def set_score(self, score): self.score = scorefrom types import MethodType# 绑定方法s1.set_score = MethodType(set_score, s1)s1.set_score(90)print(s1.score) 注意：以上方法绑定的属性和方法，只适用于当前生成的实例，不适用于新创建的实例。 给对象增加属性和方法1234567891011# 定义一个函数def set_gender(self, gender): self.gender = gender# 给类绑定属性和方法Student.set_gender = set_gender# 测试s2 = Student()s2.gender = 'male'print(s2.gender)# =&gt; 输出为 male 限制实例的属性有的时候我们不想要让一个实例,随便添加任何的属性的.这个时候我们可以用slot方法来限制创建的实例的属性. 123456789101112131415# 限制实例的属性class Student_slots(object): __slots__ = ('name', 'age', 'gender') # 使用tuple方式限制实例的属性名称# 测试# 创建新实例s3 = Student_slot()s3.name = 'bing's3.age = 12s3.gender = 'male'# 多出来的属性,会抛出异常 AttributeErrors3.score = 90# print(s3.score) 注意: slots定义的属性仅对当前类实例起作用，对继承的子类是不起作用的 对于属性的保护两种方法.123456789101112131415161718192021222324252627282930313233343536373839# 第一种方法,通过get_attr, set_attr的方式来限制对于属性的访问class Student_limit(object): def set_score(self, score): if not isinstance(score, int): raise ValueError("score is not a integer") if score &lt; 0 or score &gt; 100: raise ValueError("the score is out of range") self.__score = score def get_score(self): return self.__scores4 = Student_limit()s4.set_score(100)print(s4.get_score())# 第二种方法, Python内置的装饰器# 相对与第一种方法,更加简便# Python内置的@property装饰器就是负责把一个方法变成属性调用的# 把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值class Student_limit2(object): @property def score(self): return self.__score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError("the value is not a integer") if value &lt; 0 or value &gt; 100: raise ValueError("the value is out of range") self.__score = values5 = Student_limit2()s5.score = 60 # 实际转化为s5.set_score(60)print(s5.score) # 实际转化为s5.get_score()# 通过该方法还可以制定只读属性, 只定义getter方法,不定义setter方法 一个完整的类我们以学生类为例 1234567891011# 学生类继承自object类，所有的类都继承自object，学生类也可以继承自Person类，Primary类, 如class Student(Primary):# 如果使用多个类继承则为多重继承，具有多个类的功能，如class Student(Person, Primary)class Student(object): # 初始化实例 def __init__(self, name, id, gender): self.__name = name self.__id = id self.__gender = gender def __str__(self): return "Student's object's name &#123;&#125;".format(self.__name)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常识经典]]></title>
    <url>%2F2019%2F01%2F21%2Fcommon%20sense%2F</url>
    <content type="text"><![CDATA[托马斯 潘恩 英裔美国思想家、作家、政治活动家、理论家、革命家、激进民主主义者。1737年出生于英格兰，1774年在富兰克林的帮助下到达北美大陆，积极投身于北美的独立事业，并在1776你那以“一个英国人”的署名发表了《常识》。此书极大地鼓舞了北美民众的独立情绪，他也被视为美国开过元勋之一。有中译本将该书评价为“全世界第一本真正的畅销书”。1792年，潘恩被选入法国国民工会。1802年在杰弗逊总统的邀请下，返回美国。却因强硬的反宗教立场，不幸受尽攻击，最终于1809年6月8日在纽约去世，享年72岁。 谈政府的起源和目的 一些作家把政府和社会混为一谈，认为他们之间有很少或者没有区别；然而，他们不仅有区别，甚至有着不同的起源。社会因我们的需要产生，政府则由我们的罪恶出现；前者通过汇聚我们的感情来从正面提升我们的幸福，后者则通过限制我们的罪恶来从反面提升我们的幸福。一个鼓励交流，一个制造差别。前者扮演守护者的角色，后者则处在惩罚者的位置。 社会在任何情况下都是人民的福祉，然而政府，即使是在最好的状态，也不过是一个无法避免的恶魔，在其最坏的状态时，则令人无法忍受。当我们遭受痛苦，或遭受政府带来的同等痛苦时，或许痛苦我们也会在无政府的国建遇到，然而想到忍受的痛苦是自己一手造成，我们的不幸显得更加悲惨。政府如同衣服，是已失去纯真的象征；像构建在天堂凉亭废墟之上的国王宫殿。因为当良心的推动是明确、统一、不可抗拒且必须服从时，人便不需要立法者；但是如果情况不是这般，人便发现有必要牺牲一点自己的财产来提供保护他人财产的手段；而且就像在其他情形中一样，审慎诱导人们两害相权取其轻。 因此，安全保障是政府设立始末的真正目的，毫无疑问，用最低的成本、最大的利润以无论什么方式保障人民安全的政府是所有人所青睐的。 除了固若金汤的天国之外，万物皆有衍生罪恶的可能，而罪恶也将不可避免地发生，它会随着人们客服移民之初遇到的困难而成比例地攀升。正是这一原因将人们团结在一起，他们开始玩忽职守，开始懈怠对彼此的依赖，而且，这种疏忽表明，很有必要通过建立某种形式的政府来弥补道德上的缺陷。 也就是说，政府管理模式的诞生是因伦理道德已无力统治世界，而且这也是政府的设计和目的，即自由和安全。尽管白雪可能会刺到我们的眼睛，尽管声音可能会欺骗我们的耳朵，尽管偏见可能会扭曲我们的意志，甚至利益会模糊我们的理解力，但是自然和理性却用最朴素的声音高数世人，这一切没错。 一件事情越是简单，它就越不容易出问题，及时出现问题后也越容易修复。基于这一真理，我针对备受吹嘘的英国政体谈一谈自己的想法。在黑暗奴隶制时代诞生的英国政体，就当时来说，是顺应时代需求。在整个世界都处于专制统治下，任何尝试改变这一现状的行为都是伟大的。专制政府（尽管违背人的本性）自身也有优点，那就是，这种形式很简单。如果人们遭受痛苦，它便会知道导致人民痛苦的源头，知道如何解决，也不会迷茫于各种各样的原因以及解决办法中。 最美的辞藻如若用来描述那些要么不存在的失误，要么描述那些无法用言语表达的复杂事物，他们只不过是具有声音的词语而已。 就像一个迷恋嫖娼的男人无法正确选择或者评价自己的妻子一样，任何偏爱政府腐朽体制先入为主的思想将不能够让我们发现一个优良的体制。谈君主制和世袭制 就上帝造人的顺序来讲，人是生而平等的，之后后来的环境才可以打破这种平等。贫富差距，或许在很大程度上会被计算在内，且不用求助于压迫和贪婪，他们的名字听起来是那么的刺耳。压迫总是结果，很少或者从来不曾是财富的手段；尽管贪婪会让人远离极度的贫困，但是它也总是让人在争取财富是变得胆小如鼠。 然而没有任何真正的自然或者是宗教原因可以解释为何君臣有别。男女确实性质有别，好坏自有上帝来分。但人类种族如何来到世界诶你凌驾于万物之上，如何作为新的物种超凡出群，以及它们对人类来说不知是乐还是苦的手段，这些都值得探讨。 当一个人深思人们给君主的偶像崇拜时，无需疑惑，提起上帝，哪怕你曾经季度他的荣耀，他不应该赞成任何一种形式的政府，因为这如此不虔诚地侵害了天堂的特权。 很多人恐惧而选择向世袭制投降，一些人因迷信而屈服，而最强势的那部分人却和国王联手一并欺压百姓。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数学史概论]]></title>
    <url>%2F2019%2F01%2F16%2Fmath-history%2F</url>
    <content type="text"><![CDATA[数学史——人类文明史的重要篇章了解历史的变化是了解这门科学的一个步骤——陈省身 数学史的意义数学史对于深刻理解作为科学本身的数学，还是全面了解整个人类文明的发展都具有重要意义。 不了解数学史，就不可能全面了解整个人类文明史。 莱布尼茨说，“知道重大发明特别是那些绝非偶然的、经过深思熟虑而得到的重大发明的真正起源是很有益的。这不仅仅在于历史可以给每一个发明者应该有的评价，从而鼓舞其他人去争取同样的荣誉，而且还在于通过一些光辉的返利可以促进发现的艺术，解释发现的方法。” 庞加莱说，“如果我们希望预知数学的将来，适当的途径是研究这门学科的历史和现状。” 庞加莱[1854-1912]，被称作是最后一位数学通才。 希尔伯特[1862-1943]，“数学科学是一个不可分割的整体，它的生命力正式在于各个部分之间的联系“。 数学是-一门历史性或积累性很强的科学，如数的理论的演进；非欧几何对于欧式几何的拓宽等。 数学在人类文明史上有特殊的地位，是由数学作为一种文化的特点决定的。 首先，数学是以抽象的，追求高度精确、可靠的知识。 其次，对于一般性模式的追求，使数学具有广泛的适用性。三角形的面积公式，微积分的创立作为解一般性的无限小算法的结果。 同一组偏微分方程可以用于解流体动态，在弹性力学中用来描写振动过程，在声学中用来描述声音的传播等。 最后，数学作为一种创造性活动，还具有艺术特征，这就是对美的追求。英国数学家和哲学家罗素说，“数学不仅拥有真理，而且还有至高无上的美——一种冷峻严肃的美，就像是一尊雕像。这种美没有绘画或音乐那样华丽的装饰，它可以纯洁到崇高的程度，能够达到严格的只有最伟大的艺术才能显示的完美境界。” 什么是数学数学本身是一个历史概念，数学的内涵随着时代的变化而变化，给数学下一个一劳永逸的定义是不可能的。 数学是量的科学。数学是研究现实世界的空间形式与数量关系的科学。现代数学就是各种量之间的可能的，一般说是各种变化着的量的关系和相互联系的数学。 关于数学历史的分期]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-urllib库学习]]></title>
    <url>%2F2019%2F01%2F04%2Fpython-urllib%2F</url>
    <content type="text"><![CDATA[什么是urllib库 Python内置的一个库 urllib.request 请求模块 urllib.error 异常模块 urllib.parse url解析库 urllib.robotparser robot.text解析的库 Python3相对于Python2的变化python2123import urllib2response = urllib.urlopen("http://www.baidu.com") python3 12import urllib.requestresponse = urllib.request.urlopen("http://www.baidu.com") 注意：requests 以urllib为基础实现的 urllib.request1234567891011121314151617181920212223import urllib.request# 输出 urllib.request 的帮助文档，help(urllib.request)，如下urlopen(url, data=None, timeout=&lt;object object at 0x7f66eab220c0&gt;, *, cafile=None, capath=None, cadefault=False, context=None)url = "http://httpbin.org"response = urllib.request.urlopen(url = url + str('get'),timeout = 2)print(response.read())try: response = urllib.request.urlopen(url = url+str('get'),timeout = 0.1)except urllib.error.URLError as e: if isinstance(e.reason, socket.timeout): print("timeout error")# 构造一个Request对象request = urllib.request.Request("http://httpbin.org/")#请求对应的网站response = urllib.request.urlopen(request)# 以utf8形式解码print(response.read().decode('utf-8')) 1234567891011121314151617181920212223242526272829303132333435363738# 另外一个实例from urllib import request,parse# 请求网址url = "http://httpbin.org/post"# 头部信息headers = &#123; 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36', 'Host':'httpbin.org'&#125;## post 请求字段dict = &#123; "name":"bingwu"&#125;data = bytes(parse.urlencode(dict), encoding = 'utf8')req = request.Request(url = url,headers = headers, data = data, method = 'POST')res = request.urlopen(req)print(res.read().decode('utf-8'))# add_header 方法from urllib import request, parseurl = 'http://httpbin.org/post'mydict = &#123; 'name':'bingwu' &#125;data = bytes(parse.urlencode(mydict),encoding = 'utf8')req = request.Request(url = url, data = data, method = "POST")req.add_header('User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36')response = request.urlopen(req)print(response.read().decode('utf8')) Handler 代理123456789101112import urllib.request# 构造一个hanler对象，并创建http和https代理,用于伪装不同的ip，以防止爬虫被封proxy_handler = urllib.request.ProxyHandler(&#123; 'http':'http://127.0.0.1:8086', 'https':'https://127.0.0.1:8086'&#125;)opener = urllib.request.builder_opener(proxy_handler)response = opener.open("http://www.baidu.com")print(response.read()) Cookie 用于维持爬虫登录的一个机制1234567891011121314151617181920212223242526272829303132333435363738394041#实例1import urllib.request, http.cookiejarcookie = http.cookiejar.CookieJar()handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')for item in cookie: print(item.name + '=' + item.value)# 实例2import urllib.request, http.cookiejarfilename = 'cookie.txt'#将cookie保存成Mozilla的格式#也可以将LWPC格式的cookiecookie = http.cookiejar.MozillaCookieJar(filename)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')cookie.save(ignore_discard=True, ignore_expires=True)# 读取cookie文件中的内容，并输出cookie.load('cookie.txt',ignore_discard=True, ignore_expires=True)handler = urllib.request.HTTPCookieProcessor(cookie)openr = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')print(response.read().decode('utf8')) 异常12345678910111213141516171819202122232425262728293031323334353637# 验证 error 的错误类型import urllib.request, urllib.errortry: response = urllib.request.urlopen('http://binyong.github.io/dajkdaj.html')except urllib.error.HTTPError as e: print(e.reason, e.code, e.headers, sep = '\n')except urllib.error.URLError as e: print(e.reason)else : print('success')# 验证 error 的错误类型import urllib.request, urllib.errortry: response = urllib.request.urlopen('http://binyong.github.io/dajkdaj.html')except urllib.error.HTTPError as e: print(e.reason, e.code, e.headers, sep = '\n')except urllib.error.URLError as e: print(e.reason)else : print('success')# 验证 error 的错误类型import sockettry: response = urllib.request.urlopen("http://www.baidu.com",timeout=0.01)except urllib.error.URLError as e: print(type(e.reason)) if isinstance(e.reason, socket.timeout): print('time out')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>urllib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 爬虫基本原理]]></title>
    <url>%2F2019%2F01%2F04%2FPython-crawler-fundamentals%2F</url>
    <content type="text"><![CDATA[什么是爬虫请求网站并提取数据的自动化程序 爬虫基本流程发起请求通过http向目标站点发起请求，发送一个request，可以保护额外的header等信息（一般是必要的，不然会被检测出来） 服务器响应返回一个response，其中内容便是想要获取的页面内容，如html代码，json字符串，二进制数据（图片视频） 解析内容得到的内容可能是html，用正则表达式匹配，json，直接转为json对象解析，二进制数据则保存进一步处理。 保存数据可以存为文本，或者存储到数据库中，可以指定保存文件的格式 什么是request和responseRequest 请求方式，最常用的为get，post get post 包含一个Form data，主要用于登录 head put delete options 等 请求urlurl，统一资源定位符的简称。 请求头包含了请求时的头部信息，如user-agent, host,cookies等 请求体请求时额外携带的数据，如请求的表单数据，在做post请求的时候需要。 Respons 响应状态 200 表示成功 301 跳转 404 找不到页面 502 服务器错误 响应头 内容类型 内容长度 服务器信息 设置cookie等 响应体 包含请求资源的内容 图片 二进制数据 HTML等 代码实战1234567891011121314import requestsresponse = requests.get("http://www.baidu.com")# 修改编码格式，解决命令行中可能会出现乱码的问题response.encoding = 'utf-8'print(response.text)print(response.headers)print(response.status_code)# &lt;!-- 构造请求头 --&gt;headers = &#123;&#125;headers = &#123;'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36'&#125;response = requests.get("http://www.baidu.com",headers = headers) 能抓取怎样的信息 网页文本 图片，二进制文件保存为图片即可 123456response = requests.get("https://www.baidu.com/img/baidu_jgylogo3.gif")# 输出二进制文件的内容print(response.content)with open('/tmp/1.gif','wb') as f: f.write(response.content) f.close() 视频 其他文件 解析方式 直接解析 json解析 正则表达式 beautifulsoup pyquery xpath 怎样解决JavaScript渲染问题 分析ajax请求-返回json数据 selenium/webdriver模拟浏览器请求 123from selenium import webdriverdriver = webdriver.Chrome()driver.get("http://m.weibo.com") splash,类似于selenium模拟解析 PyV8,Ghost.py 存储数据 文本 关系型数据库，MySQL等，具有特定存储内容的一个数据库 非关系型数据库，如redis，mogodb等key-value形式 二进制文件，直接存储二进制文件即可]]></content>
      <categories>
        <category>爬虫</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 数据分析环境搭建]]></title>
    <url>%2F2018%2F12%2F31%2Fpython-analysis-environment%2F</url>
    <content type="text"><![CDATA[Python基本环境搭建（Ubuntu16.04环境下）Redis 数据库安装12$ sudo apt install redis-server 完成安装即可 Redis 配置文件的修改12345$ sudo vim /etc/redis/redis.conf # 修改/etc下的redis环境配置文件/requirepass #查找requirepass 字符，找到 “requirepass forebode 默认密码为forebode，修改为自己想要的/bind 127.0.0.1 #查找“bind 127.0.0.1”，去掉前面的 ”#“符号，即可从外部环境中访问redis，否则只能在本地访问 基本操作12345678910111213141516#在配置文件修改密码之前$ redis-cli #进入redis命令行环境中，默认端口为6379# redis命令行操作set 'a' 'b' # a为键，b为对应的值get 'a' #获取'a'对应的值#修改配置文件密码之后#重启redis$ sudo service redis restart# 进入redis命令行$ redis-cli -a 'your password'set 'a' 'b'get 'a' #如果没有输入密码，则没有访问权限 Mongodb 数据库安装12345678$ sudo apt install mongodb# 启动mongodb$ mongo&gt; #进入命令行提示符&gt; show dbs #显示数据库，默认有admin，local数据库&gt; use local #切换到local数据库&gt; db.test.insert(&#123;'a':'b'&#125;) #插入一条数据 MySQL 数据库安装12345678910111213#安装mysql数据库的客户端，安装过程中会提示输入mysql root账户的密码，牢记$ sudo apt install myslq-client#命令行下访问mysql客户端,-u 代表用户root, -p 代表密码$ myslq -u root -p# 显示当前的数据库文档&gt; show databases;#切换到mysql数据库&gt; use mysql# 查看数据库下的数据&gt; select * from db# 推出MySQL&gt; exit 修改MySQL配置文件 1234$ vim /etc/mysql/mysql.conf.d/mysqld.cnf#修改其中的 bind-address = 127.0.0.1,限制本地访问；注释之后即可远程访问 Python数据分析相关的库升级pippip3 install –upgrade pip selenium驱动浏览器的一个库，主要是用来做测试。主要针对某些使用js渲染的网站，这个时候使用requests库就无法正常获取渲染内容。 用selenium就可以直接驱动浏览器，获取内容。 代码实例： 123456789import seleniumfrom selenium import webdriverdriver = webdriver.Chrome() #这个地方要注意，会报错，主要是由于没有安装chromedriver，官网下载chromedriver，然后配置文件路径，即可。driver.get("http://www.baidu.com")# 显示网页源代码driver.page_source chromedriver的安装下载chromedriver，按照下面的步骤进行即可。 123456wget -N http://chromedriver.storage.googleapis.com/2.26/chromedriver_linux64.zipunzip chromedriver_linux64.zipchmod +x chromedriversudo mv -f chromedriver /usr/local/share/chromedriversudo ln -s /usr/local/share/chromedriver /usr/local/bin/chromedriversudo ln -s /usr/local/share/chromedriver /usr/bin/chromedriver 安装PhantomJS这是一个不显示界面的浏览器。 下载phantomjs，按照chromedriver的安装一致，将chromedriver改成phantomjs即可。 注意： 现在Phantomjs已经被selenium废弃了。自己观察输出。 lxml提供xpath一个解析方式，对网页高效的一种解析方式。 beautifulsoup4也是一个网页解析的库，依赖lxml库1234567$ pip install beautifulsoup4&gt; from bs4 import BeautifulSoup# 创建一个beautifulsoup对象，第一个参数是html代码，第二个参数是解析模式&gt; soup = BeautifulSoup("&lt;html&gt;&lt;/html&gt;","lxml")&gt; pyquery这是一个类似与jQuery的一个库，语法与jQuery，完全一致。 1234567$ pip install pyquery$ python3&gt; from pyquery import PyQuery as pq&gt; doc = pq("&lt;html&gt;&lt;/html&gt;")&gt; doc = pq("&lt;html&gt;Hello PyQuery&lt;/html&gt;")&gt; result = doc("html").text()&gt; result pymysql一个操作MySQL的存储库。12345678910import pymysql# 创建一个连接，包括主机名，用户，端口，密码，数据库等信息。conn = pymysql.connect(host = "localhost",user = "root",password = "wukaiyun", port = 3306, db = "mysql")cursor = conn.cursor()cursor.execute("select * from db")#拿到MySQL中存储数据的相关内容cursor.fetchone() pymongokey-value存储形式的关系型数据库 12345678import pymongo# 声明一个mongo对象client = pymongo.MongoClient("localhost")# 声明一个newtextdb的数据库db = client("newtextdb")#声明一个表名，并插入一条数据db['table'].insert(('name':'bob'))db['table'].find_one(('name':'bob')) redis123456789import redis# 第一个参数为用户，第二参数为端口# rd = redis.Redis("localhost",6379)# 上面注释掉的是错误代码，通过help(redis.Redis()),查询到正确用法r = redis.Redis(host ='localhost',port=6379, password='')# 设定一个键值对r.set("name",'bob')# 获取数据r.get("name") flask一个web代理的库，代理的获取，存储的一个接口 123456789# flask的一个最小应用from flask import flaskapp = Flask(__name__)@app.route("/")def hello_world(): return "hello world"if __name__ == "__main__": app.run()# 在127.0.0.1:5000下查看效果 django后台管理，路由，web服务器框架，一些模板引擎，可以利用其来做一个完整的网站；分布式爬虫的维护的管理系统，可能会用到。 jupyter相当一个笔记本，支持markdown的代码记录，运行在浏览器上，可以调试运行。 依赖于很多库，其中依赖于ipython，会自动安装 使用 jupyter notebook # 自动弹出浏览器，运行在8888端口上 # 新建一个记事本 print(&quot;hello world&quot;) #ctrl + enter运行 # 按下键盘上的”b“，新增一行]]></content>
      <categories>
        <category>Python</category>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Redis</tag>
        <tag>Mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 绘制流程图]]></title>
    <url>%2F2018%2F12%2F30%2Fmarkdown-flow%2F</url>
    <content type="text"><![CDATA[流程图&amp;&amp;注意事项注意：原生的markdown不支持流程图，可以考虑使用cmdmarkdown等markdown编辑器 以下的代码使用cmdmarkdown平台实现 代码如下 12345678910st=start: Startio=inputoutput: Verificationop=operation: You Operationcond= condition: yes or no?sub= subroutine: your subroutinee= endst-io-op-condcond(yes)-econd(no)-sub-io 效果图 说明这样几行简单的代码就生成了一个优雅的流程图。流程图大致分为两段，第一段是定义元素，第二段是定义元素之间的走向。 定义元素的语法tag=&gt;type: content:&gt;url tag就是元素名字， type是这个元素的类型，有6中类型，分别为: start # 开始 end # 结束 operation # 操作 subroutine # 子程序 condition # 条件 inputoutput # 输入或产出 content就是在框框中要写的内容，注意type后的冒号与文本之间一定要有个空格。 url是一个连接，与框框中的文本相绑定]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>流程图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Snipaste 好用的截图软件]]></title>
    <url>%2F2018%2F12%2F28%2Fsnipaste%2F</url>
    <content type="text"><![CDATA[软件Logo 软件介绍Snipaste = Snip + Paste Snipaste 是一个简单但强大的截图工具，也可以让你将截图贴回到屏幕上！ Snipaste 使用很简单，但同时也有一些较高级的用法可以进一步提升你的工作效率。 Snipaste 是免费软件，它也很安全，没有广告、不会扫描你的硬盘、更不会上传用户数据，它只做它应该做的事。 软件特色功能介绍1.要截动图的话，多了解一下可能就有了～。咱截动图不行，但是贴动图可以啊，将动图右键复制（Ctrl + C）， 然后按下F3，桌面动图很nice的好不好 2.拖延症患者，对不起，F1截图之后F3自动贴图到桌面，同时右键分组收藏，做个备忘录也是可以的 3.取色器，想要一个颜色，F1截图的时候按下c，RGB格式的颜色已经存到你的剪贴板上了，直接复制就行了。 4.做教程美滋滋，截图的时候附上文字说明，任何情况下截图都OJBK 5.斗图，打开你的素材库，按下F1截图，然后配上文字，一键开启斗图模式 6.支持截图历史记录，截图的时候按下“，”或者是“.&quot;上下翻页，即可呈现你的截图历史，历史回放.... 下载地址现目前只有Window 版本和 Mac版本（公测）对于Window 版本的推荐使用Window 10系统，在Window 7 和 xp 上会遇到各种问题，在打开的时候会提示缺少东西。比较影响用户体验。 另外现在Window 10 已经很成熟了，可以考虑上车了。 对于个人用户，是免费的。无论专业版还是个人版，功能无差异；对于企业用户，专业版是收费的。 用户手册想要获取更多信息请点击用户手册，了解更多]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Snipaste</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTex入门问题汇总]]></title>
    <url>%2F2018%2F12%2F26%2Flatex-basic%2F</url>
    <content type="text"><![CDATA[系统说明平台是Ubuntu 16.04， apt install 安装的texlive。 给新手的建议 随便选一个平台，最好是找一个简单的LaTeX编辑器 不要专注与字体等美化，先熟悉基本的语法再进一步探索 关于LaTeX使用中文的解决办法直接上代码吧 1234567891011121314151617181920212223\documentclass[]&#123;article&#125;\usepackage&#123;amsmath&#125; %公式支持\usepackage&#123;CJK&#125; %导入中文字体支持包\begin&#123;document&#125;% 参考: http://www.linuxdiyf.com/linux/3476.html or http://www.latexstudio.net/archives/3561.html%gbsn为宋体中文字体代码，gkai为楷体中文，bkai为繁体中文%宋体中文测试\begin&#123;CJK*&#125;&#123;UTF8&#125;&#123;gbsn&#125;$\sum_&#123;i = 1&#125; ^n a_i = 0$,测试中文显示\end&#123;CJK*&#125;%顯示繁體中文的代碼\begin&#123;CJK*&#125;&#123;UTF8&#125;&#123;bkai&#125;顯示繁體中文\end&#123;CJK*&#125;\end&#123;document&#125; 作者、标题、日期1234567891011121314% 在begin&#123;document&#125;之前添加如下的信息\title&#123;Your title&#125; % 添加你的title名字，注意，暂时不支持中文\author&#123;Your author&#125; %添加你的author信息\date&#123;\date&#125; % \date显示今天的日期，你可以自定义输入日期，如&quot;Feb 24&quot;等% 在\begin&#123;document&#125;下首行添加,使title信息显示在文档中，否则不会有任何效果。\begin&#123;document&#125;\maketitle....\begin&#123;document&#125; 数学公式 ^ 表示上标 _ 表示下标 $... $ 单个美元符号为行内公式， \$$... $$ 两个美元符号单独为公式开一行，并居中 \begin{equation} … \end{equation}, 单独开一行并为公式编号，还有其他方法，暂不说明。 12345678910111213%在documentclass[]&#123;article&#125; 后添加如下代码，目的是为了导入数学公式支持包，可能不同平台有不同的包，暂时没有研究\usepackage&#123;amsmath&#125; %公式支持%数学公式,三种格式化% 公式的第一种表示方法，并编号\begin&#123;equation&#125;\sum_&#123;i = 1&#125; ^n a_i = 0\end&#123;equation&#125;单独开一行的公式$$\sum_&#123;i = 1&#125; ^n a_i = 0$$，这是一个行内公式，$\sum_&#123;i = 1&#125; ^n a_i = 0$ 字体加粗、斜体、下划线、强调123456789\textbf&#123;Bold&#125; ,%加粗Bold单词\textit&#123;Italic&#125; ,%将Italic变成斜体\underline&#123;underline&#125;, %给underline添加下划线\textbf&#123;\textit&#123;bold and italic&#125;&#125;, %加粗并变成斜体%强调 \emph,将会用斜体展示\emph&#123;this is a long sentence&#125; 章节和段落、目录 \section 章节 \subsection{} 子章节，注意subsection和{}之间不要有空格，不然会创建子标题失败，原因不明，应该是语法规定，可以通过语法高亮提示修正 \paragraph 段落 \tableofcontents 目录 以上都是单独的,默认编号格式为罗马数字;默认没有缩进 12345678910111213141516%为章节添加一个目录\tableofcontents %创建一个章节\section&#123; Hello section&#125;This is a section.\subsection&#123; Hello subsection1&#125;This is a subsection.\paragraph &#123; Hello paragraph&#125;This is a paragraph.\subparagraph &#123; Hello subparagraph&#125;This is a subparagraph.\subsection &#123; Hello subsection2&#125;\paragraph&#123;this is a paragraph&#125; 换行 换行使用 “\“ 1我在第一行 \\ 我在第二行\\我在第三行]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相机基本组成（尼康d5600）]]></title>
    <url>%2F2018%2F12%2F25%2FSingle-lens-reflex-camera%2F</url>
    <content type="text"><![CDATA[1. 图像传感器（CMOS） 在胶片时代，胶片就是图像传感器 在数码时代，CMOS就是图像传感器,即感光元件。 2. 感光度（ISO） 感光度，顾名思义，即感受光线的程度 这是从胶片时代继承过来的产物，在 胶片时代 感光度就是底片对光线的反应速度，即底片盒上的数字大小，对应的数字越大，对光线的敏感性越高，达到相同的亮度，所需要的 曝光时间（底片接受光线照射的时间） 也就越短。 但是有个问题，就是感光度越高，相应的拍摄出来的画质越差， 噪点越多、细节丢失、颜色偏移。所以通常选用低感光度（XXXX-XXXX） 3. 快门速度 快门，或快门单元，简单说就是一块挡在 CMOS前面的一块板子，在快门没有按下的时候，光线照不进来，按下快门的时候，打开，让光线照在 CMOS 上面,从而得到了曝光，光线转变为电信号存储在记忆卡中。 快门速度，即 快门开启的时间, 快门开启的时间越长，进入的光线越多，曝光就会增加, 快门速度也是摄影内容的一个核心n内容—— 曝光。 同时由于快门开启，底片上记录的事物会发生重叠，总的来说就是，快门时间越长，里面的东西就会越模糊，汽车光带就是这样拍摄的，通过长时间曝光 总结：，高速快门可以记录瞬间的事物，如飞溅的水滴，奔跑的宠物，运动题材的。 低速快门可以记录时间的流逝。 4. 光圈 光圈这个参数是和镜头连接在一起的。所以我们先介绍一下镜头。 4.1 镜头镜头分为 定焦镜头 和 变焦镜头。 区别： 定焦镜头的 视角 是固定的， 变焦镜头的视角是可以在一定范围内变动的。焦距： 分为广角镜头，标准镜头和长焦镜头。通俗来讲即 照大视角的， 照人像的 和 照远距离的 4.2 光圈光圈就像是人的瞳孔，和快门速度共同决定了 进光量(即进入的光线多少）。 光圈越小，单位时间进入的光线量就越少；光圈越大，单位时间内进入的光线越多。 注意： 光圈的大小和相机镜头的F值互为倒数，F值越大，光圈越小，F值越小，光圈越大 除此之外，还会影响要拍摄的照片的效果，这里涉及到一个概念，景深。 4.3 景深景深即背景的清晰度，相机得到清晰景物的深度。背景的清晰度越高，景深越大；背景的清晰度越低（虚化），景深越浅。很好理解，类比人眼，背景越清晰，即看得越远（深入）。 如何使用 拍摄人像的时候，为了突出人物（特写），选用大光圈，低景深，模糊背景，以此来凸显人物。（虚化） 拍摄花卉，表现花卉植物的某些特点。（虚化） 总结： 光圈大，虽然会有 虚化 的效果，但是有的时候在光线很充足的时候会导致过度曝光，画面失真。 光圈小，虽然能够捕获到足够清晰、锐利的照片，但如果光圈过小，由于物理光学原理，会发生 衍射,导致画面不锐利。 5. 虚化虚化三大件，焦距，拍摄距离，光圈。 焦距越长，越容易产生虚化。 拍摄距离越近，越容易产生虚化 光圈越大，越容易产生虚化 6. 全幅 or 残幅(APS-C) 由于历史原因，在数码单反相机面世的时候，CMOS的价格非常高（36 24mm），导致相机价格很贵，这个时候聪明的工程师们想出了一个很好的解决拌饭，即减小CMOS的面积（24 13mm），以降低单反的价格，以此来更好的推广单反相机。但是这又出现了一个问题，即标题所讲的 全幅OR残幅 之争，也是每一个新手在选择相机的时候面临的一个大问题。 未完待续]]></content>
      <categories>
        <category>摄影</category>
      </categories>
      <tags>
        <tag>感光度</tag>
        <tag>分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo && GitHub Pages]]></title>
    <url>%2F2018%2F11%2F30%2FHexo-GitHub-Pages%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick InstallPlatform : Ubuntu 16.04 intall nodejs v8.9.1 ro higher12345678# install nodejs. $ sudo apt install npm # or you can visit the nodejs website download it.# clean the npm cache$ sudo npm cache clean -f# install a helper called `n`$ sudo npm intall -g n# use the `n` to install nodejs v8.9.1, which we nedd it to use the `themes/next`$ sudo n 8.9.1 Install Git1$ sudo apt install git # install the git. Install hexo12# install the `hexo` package, $ sudo npm install -g hexo-cli Init hexo12345678# create a directory ,which called `hexo`$ mkdir hexo# switch to the folder `hexo`$ cd hexo# init the folder to become the blog$ hexo init# install `node` dependency package$ npm install # or sudo npm install Quick StartCreate a new post1$ hexo new "My New Post" # then you will see a my-new-post.md in the source/_posts More info: Writing Run server1$ hexo server # or use `hexo s`,click the `http://localhost:4000` to you default browser to see the blog. More info: Server Generate static files1$ hexo generate # or use `hexo g` More info: Generating Deploy to Github Pages1$ hexo deploy # or use `hexo d` More info: Deployment Writing CategoriesIf you write the following code in you posts.md file then you will get the following scene. 1234567- Sports- Baseball- [Sports, Baseball]- [MLB, American League, Boston Red Sox]- [MLB, American League, New York Yankees]- [Movies]- [Code] Exapmle]]></content>
      <categories>
        <category>Hexo</category>
        <category>GitHub</category>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Writing CategoriesIf you write the following code in you posts.md file then you will get the following scene. 1234567- Sports- Baseball- [Sports, Baseball]- [MLB, American League, Boston Red Sox]- [MLB, American League, New York Yankees]- [Movies]- [Code] Exapmle]]></content>
  </entry>
</search>
